using Parseidon.Cli;
using Parseidon.Parser;
using Spectre.Console;
using System.CommandLine;


var rootCommand = new RootCommand("Parser generator for .NET");

var overrideOption = new Option<string>(name: "--override", description: "How to handle if the output file already exists", getDefaultValue: () => "ask")
    .FromAmong("ask", "abort", "backup", "override");
overrideOption.AddAlias("-o");

rootCommand.AddGlobalOption(overrideOption);

var parseCommand = new Command("parser", "Create parser class for the grammar as a C# class");

var namespaceOption = new Option<String>(name: "--namespace", "The namespace for the generated C# class");
namespaceOption.AddAlias("-n");
parseCommand.Add(namespaceOption);

var classnameOption = new Option<String>(name: "--classname", "The class name for the generated C# class");
classnameOption.AddAlias("-c");
parseCommand.Add(classnameOption);

rootCommand.Add(parseCommand);

var astCommand = new Command("ast", "Create the AST (Abstract Syntax Tree) for the grammar as a YAML file");
rootCommand.Add(astCommand);

var grammarFileArgument = new Argument<FileInfo>(name: "GRAMMAR-FILE", description: "The grammar file to be used");
parseCommand.Add(grammarFileArgument);
astCommand.Add(grammarFileArgument);

var outputFileArgument = new Argument<FileInfo>(name: "OUTPUT-FILE", description: "The output file");
parseCommand.Add(outputFileArgument);
astCommand.Add(outputFileArgument);

parseCommand.SetHandler(
    (grammarFile, outputFile, overrideOption, parserNamespace, parserClassname) =>
        RunParser(grammarFile, outputFile, overrideOption, (result) =>
            CreateParser(result, outputFile, overrideOption, parserNamespace, parserClassname)),
    grammarFileArgument, outputFileArgument, overrideOption, namespaceOption, classnameOption);

astCommand.SetHandler(
    (grammarFile, outputFile, overrideOption) =>
        RunParser(grammarFile, outputFile, overrideOption, (result) =>
            CreateAST(result, outputFile, overrideOption)),
    grammarFileArgument, outputFileArgument, overrideOption);

return await rootCommand.InvokeAsync(args);

static void RunParser(FileInfo grammarFile, FileInfo outputFile, String overrideOption, Action<ParseidonParser.ParseResult> processResult)
{
    ValidateFileInput(grammarFile, outputFile, overrideOption);
    ParseidonParser Parser = new ParseidonParser();
    ParseidonParser.ParseResult parseResult = Parser.Parse(File.ReadAllText(grammarFile.FullName));
    if (parseResult.Successful)
        processResult(parseResult);
    else
        ProcessMessages(parseResult.Messages);
}

static void ProcessMessages(IReadOnlyList<ParseidonParser.ParserMessage> messages)
{
    foreach (var message in messages)
        PrintMessage(message.Type, $"({message.Row}:{message.Collumn}) {message.Message}");
    Environment.Exit(1);
}

static void PrintMessage(ParseidonParser.ParserMessage.MessageType messageType, String message)
{
    var color = messageType == ParseidonParser.ParserMessage.MessageType.Error ? "red" : "yellow";
    var messageTypeText = messageType == ParseidonParser.ParserMessage.MessageType.Error ? "ERROR" : "WARNING";
    AnsiConsole.MarkupLine($"[{color}]{messageTypeText}: {Markup.Escape(message)}[/]");
}

static void CreateParser(ParseidonParser.ParseResult parseResult, FileInfo outputFile, String overrideOption, String parserNamespace, String parserClassname)
{
    CreateCodeVisitor visitor = new CreateCodeVisitor();
    ParseidonParser.Visitor.VisitResult visitorResult = parseResult.Visit(visitor);

    String code = visitorResult.Result ?? "";
    code =
        $"""
        //****************************************//
        //*                                      *//
        //* This code is generated by parseidon. *//
        //*     https://github.com/parseidon     *//
        //*                                      *//
        //*         {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss")}          *//
        //*                                      *//
        //****************************************//

        """ + code;
    if (outputFile.Exists && overrideOption.Equals("backup"))
    {
        Int32 backupFileNo = 1;
        while (File.Exists($"{outputFile.FullName}.{backupFileNo}.bak"))
            backupFileNo++;
        File.Copy(outputFile.FullName, $"{outputFile.FullName}.{backupFileNo}.bak", true);
    }

    File.WriteAllText(outputFile.FullName, code);
    AnsiConsole.MarkupLine($"[green] The parser '{outputFile.FullName}' is sucessfully created![/]");
}

static void CreateAST(ParseidonParser.ParseResult parseResult, FileInfo outputFile, String overrideOption)
{
    RenderASTVisitor visitor = new RenderASTVisitor();
    ParseidonParser.Visitor.VisitResult? visitorResult = parseResult.Visit(visitor);
    File.WriteAllText(outputFile.FullName, visitorResult?.Result ?? "");
    AnsiConsole.MarkupLine($"[green] The AST-file '{outputFile.FullName}' is sucessfully created![/]");
}

static void ValidateFileInput(FileInfo grammarFile, FileInfo outputFile, String overrideOption)
{
    if (!grammarFile.Exists)
    {
        PrintMessage(ParseidonParser.ParserMessage.MessageType.Error, $"The file '{grammarFile.FullName}' could not be found!");
        Environment.Exit(1);
    }
    if (outputFile.Exists)
    {
        if (overrideOption.Equals("abort"))
        {
            PrintMessage(ParseidonParser.ParserMessage.MessageType.Error, $"The file '{outputFile.FullName}' already exists!");
            Environment.Exit(1);
        }
        if (overrideOption.Equals("ask"))
        {
            PrintMessage(ParseidonParser.ParserMessage.MessageType.Error, $"The file '{outputFile.FullName}' already exists!");
            if (!AnsiConsole.Prompt(new ConfirmationPrompt("Should it be overwritten?")))
                Environment.Exit(1);
        }
    }
}

