using Parseidon.Parser;
using Spectre.Console;
using System.CommandLine;
using Parseidon.Cli;

var rootCommand = new RootCommand("Parser generator for .NET");

var overrideOption = new Option<string>(name: "--override", description: "How to handle if the output file already exists", getDefaultValue: () => "ask")
    .FromAmong("ask", "abort", "backup", "override");
overrideOption.AddAlias("-o");

rootCommand.AddGlobalOption(overrideOption);

var parseCommand = new Command("parser", "Create parser class for the grammar as a C# class");

var namespaceOption = new Option<String>(name: "--namespace", "The namespace for the generated C# class");
namespaceOption.AddAlias("-n");
parseCommand.Add(namespaceOption);

var classnameOption = new Option<String>(name: "--classname", "The class name for the generated C# class");
classnameOption.AddAlias("-c");
parseCommand.Add(classnameOption);

rootCommand.Add(parseCommand);

var astCommand = new Command("ast", "Create the AST (Abstract Syntax Tree) for the grammar as a YAML file");
rootCommand.Add(astCommand);

var grammarFileArgument = new Argument<FileInfo>(name: "GRAMMAR-FILE", description: "The grammar file to be used");
parseCommand.Add(grammarFileArgument);
astCommand.Add(grammarFileArgument);

var outputFileArgument = new Argument<FileInfo>(name: "OUTPUT-FILE", description: "The output file");
parseCommand.Add(outputFileArgument);
astCommand.Add(outputFileArgument);

parseCommand.SetHandler(
    (grammarFile, outputFile, overrideOption, parserNamespace, parserClassname) =>
        RunParser(grammarFile, outputFile, overrideOption, (result) =>
            CreateParser(result, outputFile, overrideOption, parserNamespace, parserClassname)),
    grammarFileArgument, outputFileArgument, overrideOption, namespaceOption, classnameOption);

astCommand.SetHandler(
    (grammarFile, outputFile, overrideOption) =>
        RunParser(grammarFile, outputFile, overrideOption, (result) =>
            CreateAST(result, outputFile, overrideOption)),
    grammarFileArgument, outputFileArgument, overrideOption);

return await rootCommand.InvokeAsync(args);

static void RunParser(FileInfo grammarFile, FileInfo outputFile, String overrideOption, Action<ParseResult> processResult)
{
    ValidateFileInput(grammarFile, outputFile, overrideOption);
    ParseidonParser Parser = new ParseidonParser();
    ParseResult parseResult = Parser.Parse(File.ReadAllText(grammarFile.FullName));
    if (parseResult.Successful)
        processResult(parseResult);
    else
        ProcessMessages(parseResult.Messages);
}

static void ProcessMessages(IReadOnlyList<ParserMessage> messages)
{
    foreach (var message in messages)
        PrintMessage(message.Type, $"({message.Row}:{message.Collumn}) {message.Message}");
    Environment.Exit(1);
}

static void PrintMessage(ParserMessage.MessageType messageType, String message)
{
    var color = messageType == ParserMessage.MessageType.Error ? "red" : "yellow";
    var messageTypeText = messageType == ParserMessage.MessageType.Error ? "ERROR" : "WARNING";
    AnsiConsole.MarkupLine($"[{color}]{messageTypeText}: {Markup.Escape(message)}[/]");
}

static void CreateParser(ParseResult parseResult, FileInfo outputFile, String overrideOption, String parserNamespace, String parserClassname)
{
    IVisitor visitor = new CreateCodeVisitor();
    IVisitResult visitorResult = parseResult.Visit(visitor);

    if (visitorResult.Successful && visitorResult is CreateCodeVisitor.IGetCode)
    {
        String code = (visitorResult as CreateCodeVisitor.IGetCode)!.Code ?? "";
        code =
            $"""
        //****************************************//
        //*                                      *//
        //* This code is generated by parseidon. *//
        //*     https://github.com/parseidon     *//
        //*                                      *//
        //*         {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss")}          *//
        //*                                      *//
        //****************************************//

        """ + code;
        if (outputFile.Exists && overrideOption.Equals("backup"))
        {
            Int32 backupFileNo = 1;
            while (File.Exists($"{outputFile.FullName}.{backupFileNo}.bak"))
                backupFileNo++;
            File.Copy(outputFile.FullName, $"{outputFile.FullName}.{backupFileNo}.bak", true);
        }

        File.WriteAllText(outputFile.FullName, code);
        AnsiConsole.MarkupLine($"[green] The parser '{outputFile.FullName}' is sucessfully created![/]");
    }
}

static void CreateAST(ParseResult parseResult, FileInfo outputFile, String overrideOption)
{
    RenderASTVisitor visitor = new RenderASTVisitor();
    IVisitResult visitResult = parseResult.Visit(visitor);
    if (visitResult.Successful && visitResult is RenderASTVisitor.IGetAST)
    {
        File.WriteAllText(outputFile.FullName, (visitResult as RenderASTVisitor.IGetAST)!.AST ?? "");
        AnsiConsole.MarkupLine($"[green] The AST-file '{outputFile.FullName}' is sucessfully created![/]");
    }
}

static void ValidateFileInput(FileInfo grammarFile, FileInfo outputFile, String overrideOption)
{
    if (!grammarFile.Exists)
    {
        PrintMessage(ParserMessage.MessageType.Error, $"The file '{grammarFile.FullName}' could not be found!");
        Environment.Exit(1);
    }
    if (outputFile.Exists)
    {
        if (overrideOption.Equals("abort"))
        {
            PrintMessage(ParserMessage.MessageType.Error, $"The file '{outputFile.FullName}' already exists!");
            Environment.Exit(1);
        }
        if (overrideOption.Equals("ask"))
        {
            PrintMessage(ParserMessage.MessageType.Error, $"The file '{outputFile.FullName}' already exists!");
            if (!AnsiConsole.Prompt(new ConfirmationPrompt("Should it be overwritten?")))
                Environment.Exit(1);
        }
    }
}

