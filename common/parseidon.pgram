@namespace: Parseidon.Parser;
@class: ParseidonParser;
@rootnode: Grammar;

Grammar             = Option* Definition+ Spacing;
Option              = Spacing '@' ValuePair LineEnd;
Definition          = Spacing RuleOptions Identifier -Equal Spacing Expression Properties? LineEnd;
:RuleOptions        = UseRuleNameAsError? (IsTerminal / Drop / TreatInline)?;

:Properties         = -CurlyBracketOpen Spacing Property (',' Spacing Property)* -CurlyBracketClose;
Property            = Identifier (-ValueAssign Value)?;
ValuePair           = Identifier -ValueAssign Value;
:ValueAssign        = ':' Spacing;
:Value              = Literal / Number / Boolean / CSharpIdentifier;

Expression          = Sequence (Or Spacing Sequence)*;
Sequence            = Prefix+;
Prefix              = Drop? Suffix;
Suffix              = Primary ((Optional / ZeroOrMore / OneOrMore)? Spacing);
:Primary            = TreatInline? Identifier
                    / Literal
                    / -BracketOpen Spacing Expression -BracketClose Spacing
                    / Regex
                    / AllChar;  
^$Identifier        = IdentStart IdentCont Spacing;
IdentStart          = [a-zA-Z_];
IdentCont           = [a-zA-Z0-9_]*;
^$CSharpIdentifier  = IdentStart CSharpIdentCont Spacing {ErrorName: 'C#-Identifier'};
CSharpIdentCont     = [a-zA-Z0-9_.]*;
^$Literal           = (SingleQuotedLiteral / DoubleQuotedLiteral) Spacing ;
:SingleQuotedLiteral= (-'\'' Char*  -'\'');
:DoubleQuotedLiteral= (-'"' Char* -'"');
Char                = [^'\\] / '\\\'' / '\\\\' / EscapeChars / UnicodeChars;
Regex               = CharacterClass Quantifier? Spacing;
$CharacterClass     = SquareBracketOpen Negation? ClassContent+ SquareBracketClose;
:Negation           = '^';
ClassContent        = CharRange / PredefinedClass / EscapedChar / SingleChar;
:CharRange          = SingleChar '-' SingleChar;
SingleChar          = [^\\\[\]\-] / UnicodeChars;
EscapedChar         = '\\' [.\\\[\]\-\^];
PredefinedClass     = '\\d' / '\\D' / '\\w' / '\\W' / '\\s' / '\\S' / '\\t' / '\\r' / '\\n' / '\\v' / '\\f';
:Quantifier         = CurlyBracketOpen Spacing Number CurlyBracketClose;
AllChar             = Dot Spacing;

Or                  = '/';
Optional            = '?';
ZeroOrMore          = '*';
OneOrMore           = '+';
Drop                = '-';
IsTerminal          = '$' DontEscapeOutput?;
:DontEscapeOutput   = '$';
TreatInline         = ':';
UseRuleNameAsError  = '^';

EscapeChars         = '\\' [\\0abfnrtv"'?];
$$UnicodeChars      = '\\u' [0-9a-fA-F]{4};

:Equal              = '=';
^-LineEnd           = Spacing ';';
:Dot                = '.';
-Spacing            = (NewLine / WhiteSpace / Comment)*;
^WhiteSpace         = [ \t];
^NewLine            = '\r\n' / [\r\n];
^$Number            = ('0' / ([1-9] [0-9]*)) Spacing;
Comment             = '#' [^\r\n]*;
:BracketOpen        = '(';
:BracketClose       = ')';
:CurlyBracketOpen   = '{';
:CurlyBracketClose  = '}';
:SquareBracketOpen  = '[';
:SquareBracketClose = ']';
$Boolean            = (True / False) Spacing;
:True               = 'true';
:False              = 'false';
