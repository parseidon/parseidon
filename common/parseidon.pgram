@namespace: Parseidon.Parser;
@class: ParseidonParser;
@rootnode: Grammar;

# Grammar
Grammar             = _(Option_)* (Definition / TMDefinition)+;

Option              = '@' ValuePair_LineEnd;

# Rule structure
Definition          = RuleOptions Identifier_-Equal_Expression Properties?_LineEnd_;
:RuleOptions        = UseRuleNameAsError? (IsTerminal / Drop)? TreatInline?;
Expression          = Sequence (Or_Sequence)*;
Sequence            = Prefix+;
Prefix              = Drop? Suffix;
Suffix              = Primary (Optional / ZeroOrMore / OneOrMore)?_;
:Primary            = TreatInline? Identifier
                    / Literal
                    / -BracketOpen_Expression_-BracketClose
                    / Regex
                    / AllChar;  
:Properties         = -CurlyBracketOpen_ValuePair_(','_ValuePair_)* -CurlyBracketClose;

# TextMate rule structure
TMDefinition        = TMIdentifier_-Equal_TMMatchSequence_(TMIncludes?_TMMatchSequence_)? LineEnd_;
TMIncludes          = CurlyBracketOpen_(TMIdentifier_(-Or_TMIdentifier_)*)? CurlyBracketClose;
TMMatchSequence    = (TMMatch_)+;
TMMatch            = Identifier 
                    / TreatInline TMIdentifier
                    / TMRegEx
                    / -BracketOpen_TMMatchSequence_-BracketClose; 
$TMRegEx            = -'!\'' TMRegExChar+ -'\'';
TMRegExChar         = [^'\\]
                    / '\\\''
                    / '\\\\'
                    / EscapeChars
                    / UnicodeChars;

# TextMate Identifier
^$TMIdentifier      = '!' IdentStart TMIdentCont {ErrorName: 'TextMate-Identifier'};
TMIdentCont         = [a-zA-Z0-9.\-]*;

# Values
ValuePair           = Identifier_(-ValueAssign_Value_)?;
:ValueAssign        = Colon;
:Value              = Literal / Number / Boolean / CSharpIdentifier;
^$Number            = ('0' / ([1-9] [0-9]*));
$Boolean            = (True / False);
:True               = 'true';
:False              = 'false';
^$CSharpIdentifier  = IdentStart CSharpIdentCont {ErrorName: 'C#-Identifier'};
CSharpIdentCont     = ('.'? [a-zA-Z0-9])*;

!meta.test          = Identifier {!meta.test / !meta.test} RegEx !'hallo';

# Identifier
^$Identifier        = Underscore / (IdentStart IdentCont);
IdentStart          = [a-zA-Z];
IdentCont           = [a-zA-Z0-9]*;

# Literal
^$Literal           = (SingleQuotedLiteral / DoubleQuotedLiteral);
:SingleQuotedLiteral= (-'\'' Char*  -'\'');
:DoubleQuotedLiteral= (-'"' Char* -'"');
Char                = [^'\\] / '\\\'' / '\\\\' / EscapeChars / UnicodeChars;
EscapeChars         = '\\' [\\0abfnrtv"'?];

# Regular Expression
Regex               = CharacterClass Quantifier?;
$CharacterClass     = SquareBracketOpen Negation? ClassContent+ SquareBracketClose;
:Negation           = '^';
ClassContent        = CharRange / PredefinedClass / EscapedChar / SingleChar;
:CharRange          = SingleChar '-' SingleChar;
SingleChar          = [^\\\[\]\-] / UnicodeChars;
EscapedChar         = '\\' [.\\\[\]\-\^];
PredefinedClass     = '\\d' / '\\D' / '\\w' / '\\W' / '\\s' / '\\S' / '\\t' / '\\r' / '\\n' / '\\v' / '\\f';
:Quantifier         = CurlyBracketOpen Number CurlyBracketClose;

# All characters
AllChar             = Dot;

# Operator
Or                  = '/';

# Quantifier
Optional            = '?';
ZeroOrMore          = '*';
OneOrMore           = '+';

# Rule markers
Drop                = '-';
IsTerminal          = '$' DontEscapeOutput?;
:DontEscapeOutput   = '$';
TreatInline         = ':';
UseRuleNameAsError  = '^';

$$UnicodeChars      = '\\u' [0-9a-fA-F]{4};

# Grammar structure
^-:LineEnd          = ';';
-_                  = (NewLine / WhiteSpace / Comment)*;
^WhiteSpace         = [ \t];
^NewLine            = '\r\n' / [\r\n];
Comment             = '#' [^\r\n]*;

# Shared characters
:Equal              = '=';
:Dot                = '.';
:Colon              = ':';
:BracketOpen        = '(';
:BracketClose       = ')';
:CurlyBracketOpen   = '{';
:CurlyBracketClose  = '}';
:SquareBracketOpen  = '[';
:SquareBracketClose = ']';
:Underscore         = '_';

