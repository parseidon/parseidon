@namespace: Parseidon.Parser;
@class: ParseidonParser;
@rootnode: Grammar;

# Grammar
Grammar                 = _(Option_)* (Definition / TMDefinition)+;

Option                  = '@' ValuePair_LineEnd;
# Definition structure
Definition              = DefinitionOptions Identifier_-Equal_Expression Properties?_LineEnd_;
:DefinitionOptions      = UseDefinitionNameAsError? (IsTerminal / Drop)? TreatInline?;
Expression              = Sequence (Or_Sequence)*;
Sequence                = Prefix+;
Prefix                  = Drop? Suffix;
Suffix                  = Primary (Optional / ZeroOrMore / OneOrMore)?_;
:Primary                = TreatInline? Identifier
                        / Literal
                        / -BracketOpen_Expression_-BracketClose
                        / Regex
                        / AllChar;  
:Properties             = -CurlyBracketOpen_ValuePair_(','_ValuePair_)* -CurlyBracketClose;

# TextMate definition structure
TMDefinition            = TMIdentifier_-Equal_(TMNamedExpression / TMExpression)_LineEnd_;
:TMNamedExpression      = TMScopeName -BracketOpen_TMExpression_-BracketClose;
:TMExpression           = (TMMatchSequence_(TMIncludes?_TMMatchSequence_)?) / TMIncludes;
TMIncludes              = SquareBracketOpen_(TMInclude_(-Or_TMInclude_)*)? SquareBracketClose;
:TMInclude              = TMIdentifier / Identifier;
TMMatchSequence         = (TMMatch_)+;
TMMatch                 = TMScopeName? -AngleBracketOpen_Expression_-AngleBracketClose 
                        / TMRegEx
                        / TMScopeName? -BracketOpen_TMMatchSequence_-BracketClose; 
$TMRegEx                = -'!\'' TMRegExChar+ -'\'';
TMRegExChar             = [^'\\]
                        / '\\\''
                        / '\\\\'
                        / EscapeChars
                        / UnicodeChars;
$TMScopeName            = IdentStart TMScopeNameCont -Colon {ErrorName: 'TextMate scope name'};
:TMScopeNameCont        = (('.' / '_' / '-')? [a-zA-Z0-9])*;


# TextMate Identifier
^$TMIdentifier          = TMIdentifierPrefix Identifier {ErrorName: 'TextMate identifier'}; 
-:TMIdentifierPrefix    = ExclamationMark;

# Values
ValuePair               = Identifier_(-ValueAssign_Value_)?;
:ValueAssign            = Colon;
:Value                  = Literal / Number / Boolean / CSharpIdentifier;
!Value                  = [ !CSharpIdentifier / !Number / !Literal / !Boolean];
^$Number                = ('0' / ([1-9] [0-9]*));
!Number                 = constant.numeric:<Number>;
$Boolean                = (True / False);
!Boolean                = constant.language:<Boolean>;
:True                   = 'true';
:False                  = 'false';
^$CSharpIdentifier      = IdentStart CSharpIdentCont {ErrorName: 'C# identifier'};
!CSharpIdentifier       = string.unquoted:<CSharpIdentifier>;
:CSharpIdentCont        = ('.'? [a-zA-Z0-9])*;

# Identifier
^$Identifier            = Underscore / (IdentStart IdentCont);
:IdentStart             = [a-zA-Z];
:IdentCont              = [a-zA-Z0-9]*;

# Literal
^$Literal               = (SingleQuotedLiteral / DoubleQuotedLiteral);
!Literal                = [ !SingleQuotedLiteral / !DoubleQuotedLiteral ];
:SingleQuotedLiteral    = (-'\'' Char*  -'\'') {tmscope: string.quoted.single};
!SingleQuotedLiteral    = string.quoted.single:<SingleQuotedLiteral>;
:DoubleQuotedLiteral    = (-'"' Char* -'"') {tmscope: string.quoted.double};
!DoubleQuotedLiteral    = string.quoted.double:<DoubleQuotedLiteral>;
Char                    = [^'\\] / '\\\'' / '\\\\' / EscapeChars / UnicodeChars;
EscapeChars             = '\\' [\\0abfnrtv"'?];

# Regular Expression
Regex                   = CharacterClass Quantifier?;
$CharacterClass         = SquareBracketOpen Negation? ClassContent+ SquareBracketClose;
:Negation               = '^';
ClassContent            = CharRange / PredefinedClass / EscapedChar / SingleChar;
:CharRange              = SingleChar '-' SingleChar;
SingleChar              = [^\\\[\]\-] / UnicodeChars;
EscapedChar             = '\\' [.\\\[\]\-\^];
PredefinedClass         = '\\d' / '\\D' / '\\w' / '\\W' / '\\s' / '\\S' / '\\t' / '\\r' / '\\n' / '\\v' / '\\f';
:Quantifier             = CurlyBracketOpen Number CurlyBracketClose;

# All characters
AllChar                 = Dot;

# Operator
Or                      = '/';

# Quantifier
Optional                = '?';
ZeroOrMore              = '*';
OneOrMore               = '+';

# Definition markers
Drop                    = '-';
IsTerminal              = '$' DontEscapeOutput?;
:DontEscapeOutput       = '$';
TreatInline             = Colon;
UseDefinitionNameAsError= '^';

$$UnicodeChars          = '\\u' [0-9a-fA-F]{4};

# Grammar structure
^-:LineEnd              = ';';
-_                      = (NewLine / WhiteSpace / Comment)*;
^WhiteSpace             = [ \t];
^NewLine                = '\r\n' / [\r\n];
Comment                 = '#' [^\r\n]* {tmscope: comment.line};

# Shared characters
:Equal                  = '=';
:Dot                    = '.';
:Colon                  = ':';
:BracketOpen            = '(';
:BracketClose           = ')';
:CurlyBracketOpen       = '{';
:CurlyBracketClose      = '}';
:SquareBracketOpen      = '[';
:SquareBracketClose     = ']';
:AngleBracketOpen       = '<';
:AngleBracketClose      = '>';
:Underscore             = '_';
:ExclamationMark        = '!';

