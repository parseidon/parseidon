@namespace: Parseidon.Parser;
@class: ParseidonParser;
@root: Grammar;

@displayname: Parseidon;
@scopename: source.parseidon;
@filetype: pgram;
@version: '1.0.0';
@linecomment: '#';

# Grammar
Grammar                 = _(Option_)* (Definition | TMDefinition)+;
!Grammar                = <Caret> [ Comment, !Option, !Definition, !TMDefinition ] <Dollar>;

Option                  = AtSign ValuePair_LineEnd;
!Option                 = meta.option:(variable.other:(<AtSign> <Identifier>) <Colon> [ !Value ] <LineEnd>);

# Definition structure
Definition              = DefinitionOptions Identifier_-Equal_Expression Properties?_LineEnd_;
!Definition             = meta.definition.grammar:(<DefinitionOptions> entity.name.type:<Identifier> <_Equal> [ !Identifier, Literal, !Properties, Regex ] <_LineEnd>);
:DefinitionOptions      = UseDefinitionNameAsError? (IsTerminal | Drop)? TreatInline?;
Expression              = Sequence (Or_Sequence)*;
Sequence                = Prefix+;
Prefix                  = Drop? Suffix;
Suffix                  = Primary (Optional | ZeroOrMore | OneOrMore)?_;
:Primary                = TreatInline? Identifier
                        | Literal
                        | -BracketOpen_Expression_-BracketClose
                        | Regex
                        | AllChar;  
:Properties             = -CurlyBracketOpen_ValuePair_(Comma_ValuePair_)* -CurlyBracketClose;
!Properties             = meta.properties:(<CurlyBracketOpen> [ !Property, !BoolProperty ] <CurlyBracketClose>);
!Property               = variable.other:<Identifier> !'\s*' <Colon> !'\s*' [ !Value ] <_> !'(,)|(?=})';
!BoolProperty           = variable.other:<Identifier> <_> !'(?=})';

# TextMate definition structure
TMDefinition            = TMIdentifier_-Equal_(TMNamedExpression | TMExpression)_LineEnd_;
!TMDefinition           = meta.definition.textmate:(<TMIdentifier> <_Equal> [ !TMMatchDefinition, !TMMatchExpression, TMRegEx, !TMInclude ] <_LineEnd>);
:TMNamedExpression      = TMScopeName -BracketOpen_TMExpression_-BracketClose;
:TMExpression           = (TMMatchSequence_(TMIncludes?_TMMatchSequence_)?) | TMIncludes;
TMIncludes              = SquareBracketOpen_(TMInclude_(-Comma_TMInclude_)*)? SquareBracketClose;
:TMInclude              = TMIdentifier | Identifier;
!TMInclude              = <SquareBracketOpen> [ !TMIdentifier, !Identifier ] <SquareBracketClose>;
TMMatchSequence         = (TMMatch_)+;
TMMatch                 = TMScopeName? -AngleBracketOpen_Expression_-AngleBracketClose 
                        | TMRegEx
                        | TMScopeName? -BracketOpen_TMMatchSequence_-BracketClose; 
!TMMatchDefinition      = <TMScopeName? AngleBracketOpen> [ !Identifier, Literal, !Properties, Regex ] <AngleBracketClose>;
!TMMatchExpression      = <TMScopeName? BracketOpen> [ !TMMatchDefinition, !TMMatchExpression, TMRegEx, !TMInclude ] <BracketClose>;
$TMRegEx                = -'!\'' TMRegExChar+ -'\'' {tmpattern: string.regexp};
TMRegExChar             = [^'\\]
                        | '\\\''
                        | '\\\\'
                        | Regex
                        | EscapedChar
                        | PredefinedClass
                        | UnicodeChars;
$TMScopeName            = IdentStart TMScopeNameCont -Colon {errorname: 'TextMate scope name', tmscope: string.unquoted};
:TMScopeNameCont        = ((Dot | Underscore | Hyphen)? [a-zA-Z0-9])*;

# TextMate Identifier
^$TMIdentifier          = TMIdentifierPrefix Identifier {errorname: 'TextMate identifier', tmscope: keyword.other}; 
!TMIdentifier           = <TMIdentifier>; # !'(?!:)';
-:TMIdentifierPrefix    = ExclamationMark;

# Values
ValuePair               = Identifier_(-ValueAssign_Value_)?;
:ValueAssign            = Colon;
:Value                  = Literal
                        | Number
                        | Boolean
                        | CSharpIdentifier;
!Value                  = [ CSharpIdentifier, Boolean, Number, Literal ];
^$Number                = ('0' | ([1-9] [0-9]*)) {tmpattern: constant.numeric};
$Boolean                = (True | False) {tmpattern: constant.language};
:True                   = 'true';
:False                  = 'false';
^$CSharpIdentifier      = IdentStart CSharpIdentCont {tmpattern: string.unquoted, errorname: 'C# identifier'};
:CSharpIdentCont        = (Dot? [a-zA-Z0-9])*;

# Identifier
^$Identifier            = Underscore | (IdentStart IdentCont);
!Identifier             = entity.name.type:<Identifier> !'(?!:)';
:IdentStart             = [a-zA-Z];
:IdentCont              = [a-zA-Z0-9]*;

# Literal
^$Literal               = (-quote Char*  -quote) {tmpattern: string.quoted.single};
Char                    = [^'\\] | '\\\'' | '\\\\' | EscapeChars | UnicodeChars;
EscapeChars             = '\\' [\\0abfnrstv"'?];

# Regular Expression
Regex                   = CharacterClass Quantifier? {tmpattern: string.regexp};
$CharacterClass         = SquareBracketOpen Negation? ClassContent+ SquareBracketClose;
:Negation               = Caret;
ClassContent            = CharRange | PredefinedClass | EscapedChar | SingleChar;
:CharRange              = SingleChar Hyphen SingleChar;
SingleChar              = [^\\\[\]\-] | UnicodeChars;
EscapedChar             = Backslash (Dot | Caret | Dollar | Asterisk | Plus | Question | BracketOpen | BracketClose | SquareBracketOpen | SquareBracketClose | CurlyBracketOpen | CurlyBracketClose | Pipe | Backslash | Hyphen);
PredefinedClass         = '\\d' | '\\D' | '\\w' | '\\W' | '\\s' | '\\S' | '\\t' | '\\r' | '\\n' | '\\v' | '\\f';
:Quantifier             = CurlyBracketOpen Number CurlyBracketClose;

# All characters
AllChar                 = Dot;

# Operator
Or                      = Pipe;

# Quantifier
Optional                = Question;
ZeroOrMore              = Asterisk;
OneOrMore               = Plus;

# Definition markers
Drop                    = Hyphen {tmscope: keyword.operator.Drop};
IsTerminal              = Dollar DontEscapeOutput? {tmscope: keyword.operator.IsTerminal};
:DontEscapeOutput       = Dollar {tmscope: keyword.operator.DontEscapeOutput};
TreatInline             = Colon {tmscope: keyword.operator.TreatInline};
UseDefinitionNameAsError= Caret {tmscope: keyword.operator.UseDefinitionNameAsError};

$$UnicodeChars          = '\\u' [0-9a-fA-F]{4};

# Grammar structure
^-:LineEnd              = Semicolon;
-_                      = (NewLine | WhiteSpace | Comment)*;
^WhiteSpace             = [ \t];
^NewLine                = '\r\n' | [\r\n];
Comment                 = Hash [^\r\n]* {tmpattern: comment.line, tmscope: comment.line};

# Shared characters
:Equal                  = '=';
:Dot                    = '.';
:Colon                  = ':';
:BracketOpen            = '(' {tmscope: punctuation.parenthesis.open, bracketopen: bracket};
:BracketClose           = ')' {tmscope: punctuation.parenthesis.close, bracketclose: bracket};
:CurlyBracketOpen       = '{' {tmscope: punctuation.curlybrace.open, bracketopen: curly};
:CurlyBracketClose      = '}' {tmscope: punctuation.curlybrace.close, bracketclose: curly};
:SquareBracketOpen      = '[' {tmscope: punctuation.squarebracket.open, bracketopen: square};
:SquareBracketClose     = ']' {tmscope: punctuation.squarebracket.close, bracketclose: square};
:AngleBracketOpen       = '<' {tmscope: punctuation.anglebracket.open, bracketopen: angle};
:AngleBracketClose      = '>' {tmscope: punctuation.anglebracket.open, bracketclose: angle};
:Underscore             = '_';
:ExclamationMark        = '!';
:Pipe                   = '|';
:AtSign                 = '@';
:Dollar                 = '$';
:Comma                  = ',';
:Asterisk               = '*';
:Plus                   = '+';
:Hyphen                 = '-';
:Semicolon              = ';';
:Caret                  = '^';
:Question               = '?';
:Hash                   = '#';
:Backslash              = '\\';
:quote                  = '\'' {quote};

