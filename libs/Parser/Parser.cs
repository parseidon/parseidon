//****************************************//
//*                                      *//
//* This code is generated by parseidon. *//
//*     https://github.com/parseidon     *//
//*                                      *//
//*         2025-11-10 22:48:41          *//
//*                                      *//
//****************************************//
#nullable enable

using System.Text;
using System.Text.RegularExpressions;

namespace Parseidon.Parser
{
    public interface IVisitResult
    {
        Boolean Successful { get; }
        IReadOnlyList<ParserMessage> Messages { get; }
    }

    public interface IVisitor
    {
        Object GetContext(ParseResult parseResult);
        IVisitResult GetResult(Object context, Boolean successful, IReadOnlyList<ParserMessage> messages);
    }

    public interface INodeVisitor : IVisitor
    {
        ProcessNodeResult ProcessCSharpIdentifierNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessClassNameNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessDefinitionNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessDotNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessDropNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessExpressionNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessGrammarNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessIdentifierNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessIsTerminalNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessLiteralNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessNamespaceNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessNumberNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessOneOrMoreNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessOptionalNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessPrefixNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessPrimaryNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessRegexNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessRegularExpressionNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessRootNodeNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessSequenceNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessSuffixNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTreatInlineNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessZeroOrMoreNode(Object context, ASTNode node, IList<ParserMessage> messages);
        void BeginVisit(Object context, ASTNode node);
        void EndVisit(Object context, ASTNode node);
    }

    public enum ProcessNodeResult
    {
        Success,
        Error
    }

    public class MessageContext
    {
        private String _text;
        internal MessageContext(String text)
        {
            _text = text;
        }

        public (UInt32 Row, UInt32 Column) CalculateLocation(Int32 position)
        {
            Int32 row = 1;
            Int32 column = 1;
            Int32 limit = position;
            if (limit > _text.Length)
                limit = _text.Length;

            for (Int32 index = 0; index < limit; index++)
            {
                if (_text[index] == '\n')
                {
                    row++;
                    column = 1;
                }
                else
                {
                    column++;
                }
            }

            return ((UInt32)row, (UInt32)column);
        }
    }

    public class ParseResult
    {
        private class EmptyResult : IVisitResult
        {
            public EmptyResult(Boolean successful, IReadOnlyList<ParserMessage> messages)
            {
                Successful = successful;
                Messages = messages;
            }
            public Boolean Successful { get; }
            public IReadOnlyList<ParserMessage> Messages { get; }
        }

        public ParseResult(ASTNode? rootNode, MessageContext messageContext, IReadOnlyList<ParserMessage> messages)
        {
            RootNode = rootNode;
            MessageContext = messageContext;
            Messages = new List<ParserMessage>(messages);
        }

        public Boolean Successful { get => RootNode is not null; }
        public ASTNode? RootNode { get; }
        public IReadOnlyList<ParserMessage> Messages { get; }
        public MessageContext MessageContext { get; }

        public IVisitResult Visit(IVisitor visitor)
        {
            if (visitor is null)
                throw new ArgumentNullException(nameof(visitor));
            List<ParserMessage> visitMessages = new List<ParserMessage>();
            if (Successful)
            {
                try
                {
                    Object context = visitor.GetContext(this);
                    if (visitor is INodeVisitor)
                        DoVisit(context, (visitor as INodeVisitor)!, RootNode!, visitMessages);
                    return visitor.GetResult(context, true, visitMessages);
                }
                catch (GrammarException ex)
                {
                    visitMessages.Add(new ParserMessage(ex.Message, ParserMessage.MessageType.Error, (ex.Row, ex.Column)));
                }
            }
            return new EmptyResult(false, visitMessages);
        }

        private ProcessNodeResult DoVisit(Object context, INodeVisitor visitor, ASTNode node, IList<ParserMessage> messages)
        {
            visitor.BeginVisit(context, node);
            try
            {
                if (node == null)
                    return ProcessNodeResult.Error;
                Boolean result = true;
                foreach (ASTNode child in node.Children)
                    result = result && (DoVisit(context, visitor, child, messages) == ProcessNodeResult.Success);
                result = result && (CallEvent(context, visitor, node.TokenId, node, messages) == ProcessNodeResult.Success);
                return result ? ProcessNodeResult.Success : ProcessNodeResult.Error;
            }
            finally
            {
                visitor.EndVisit(context, node);
            }
        }

        private ProcessNodeResult CallEvent(Object context, INodeVisitor visitor, Int32 tokenId, ASTNode node, IList<ParserMessage> messages)
        {
            switch (tokenId)
            {
                case 26: return visitor.ProcessCSharpIdentifierNode(context, node, messages);
                case 38: return visitor.ProcessClassNameNode(context, node, messages);
                case 36: return visitor.ProcessDefinitionNode(context, node, messages);
                case 7: return visitor.ProcessDotNode(context, node, messages);
                case 14: return visitor.ProcessDropNode(context, node, messages);
                case 34: return visitor.ProcessExpressionNode(context, node, messages);
                case 41: return visitor.ProcessGrammarNode(context, node, messages);
                case 29: return visitor.ProcessIdentifierNode(context, node, messages);
                case 13: return visitor.ProcessIsTerminalNode(context, node, messages);
                case 24: return visitor.ProcessLiteralNode(context, node, messages);
                case 39: return visitor.ProcessNamespaceNode(context, node, messages);
                case 3: return visitor.ProcessNumberNode(context, node, messages);
                case 15: return visitor.ProcessOneOrMoreNode(context, node, messages);
                case 17: return visitor.ProcessOptionalNode(context, node, messages);
                case 32: return visitor.ProcessPrefixNode(context, node, messages);
                case 30: return visitor.ProcessPrimaryNode(context, node, messages);
                case 22: return visitor.ProcessRegexNode(context, node, messages);
                case 21: return visitor.ProcessRegularExpressionNode(context, node, messages);
                case 37: return visitor.ProcessRootNodeNode(context, node, messages);
                case 33: return visitor.ProcessSequenceNode(context, node, messages);
                case 31: return visitor.ProcessSuffixNode(context, node, messages);
                case 12: return visitor.ProcessTreatInlineNode(context, node, messages);
                case 16: return visitor.ProcessZeroOrMoreNode(context, node, messages);
            }
            return ProcessNodeResult.Success;
        }
    }

    public class GrammarException : Exception
    {
        public GrammarException(String message, UInt32 row, UInt32 column) : base(message)
        {
            Row = row;
            Column = column;
        }

        public UInt32 Row { get; }
        public UInt32 Column { get; }
    }

    public class ASTNode
    {
        private List<ASTNode> _children { get; } = new List<ASTNode>();
        private ASTNode? _parent = null;

        public String Text { get; internal set; }
        public String Name { get; private set; }
        public IReadOnlyList<ASTNode> Children { get => _children; }
        public Int32 TokenId { get; private set; }
        public Int32 Position { get; internal set; }
        public ASTNode? Parent { get => _parent; }

        internal ASTNode(Int32 tokenId, String name, String text, Int32 position)
        {
            Text = text;
            TokenId = tokenId;
            Name = name;
            Position = position;
        }

        internal void AssignFrom(ASTNode node)
        {
            Int32 nodeIndex = _children.IndexOf(node);
            if (nodeIndex >= 0)
            {
                Text = node.Text;
                TokenId = node.TokenId;
                Position = node.Position;
                List<ASTNode> tempChildren = new List<ASTNode>(node.Children);
                foreach (ASTNode child in tempChildren)
                {
                    child.SetParent(this, nodeIndex);
                    nodeIndex++;
                }
                _children.Remove(node);
            }
        }

        internal String GetText()
        {
            if (Children.Count > 0)
                return String.Join("", Children.Select(x => x.GetText()));
            else
                return Text;
        }

        internal void SetParent(ASTNode? parent, Int32 index = -1)
        {
            if (_parent != null)
                _parent._children.Remove(this);
            _parent = parent;
            if (_parent != null)
            {
                if (index < 0)
                    _parent._children.Add(this);
                else
                    _parent._children.Insert(index, this);
            }
        }

        internal void AddChild(ASTNode? child)
        {
            if (child != null)
                _children.Add(child);
        }

        internal void ClearChildren()
        {
            _children.Clear();
        }
    }

    public class ParserMessage
    {
        public enum MessageType
        {
            Warning,
            Error
        }

        public ParserMessage(String message, MessageType type, (UInt32 row, UInt32 column) position)
        {
            Message = message;
            Row = position.row;
            Column = position.column;
            Type = type;
        }

        public String Message { get; }
        public UInt32 Row { get; }
        public UInt32 Column { get; }
        public MessageType Type { get; }
    }

    public class ParseidonParser
    {
        public ParseResult Parse(String text)
        {
            ParserState state = new ParserState(text, new MessageContext(text));
            ASTNode actualNode = new ASTNode(-1, "ROOT", "", 0);
            String? errorName = null;
            Boolean successful = CheckRule_Grammar(actualNode, state, errorName) && state.Position == text.Length - 1;
            if (successful)
                state.NoError(state.Position);
            return new ParseResult(successful ? actualNode : null, state.MessageContext, state.Messages);
        }

        private class ParserState
        {
            public ParserState(String text, MessageContext messageContext)
            {
                Text = text;
                TextLength = Text.Length;
                MessageContext = messageContext;
            }

            private readonly List<String> _terminalNames = new List<String>();
            private Int32 _lastErrorPosition;
            private List<String> _errorExpectations = new List<String>();
            private List<ParserMessage> _messages = new List<ParserMessage>();

            internal String Text { get; }
            internal Int32 TextLength { get; }
            internal Int32 Position { get; set; } = 0;
            internal Boolean Eof => !(Position < Text.Length);
            internal MessageContext MessageContext { get; }
            internal IReadOnlyList<ParserMessage> Messages
            {
                get
                {
                    var tempMessages = new List<ParserMessage>(_messages);
                    _errorExpectations.ForEach((expectation) => tempMessages.Add(new ParserMessage(expectation, ParserMessage.MessageType.Error, MessageContext.CalculateLocation(_lastErrorPosition))));
                    return tempMessages;
                }
            }

            private String? GetCurrentTerminalName()
            {
                return _terminalNames.Count > 0 ? _terminalNames[_terminalNames.Count - 1] : null;
            }

            public TerminalScope EnterTerminal(String? ruleName)
            {
                Boolean pushed = false;
                if (!String.IsNullOrWhiteSpace(ruleName))
                {
                    _terminalNames.Add(ruleName!);
                    pushed = true;
                }
                return new TerminalScope(this, pushed);
            }

            private void LeaveTerminal(Boolean shouldPop)
            {
                if (shouldPop && (_terminalNames.Count > 0))
                    _terminalNames.RemoveAt(_terminalNames.Count - 1);
            }

            public readonly struct TerminalScope : IDisposable
            {
                private readonly ParserState _state;
                private readonly Boolean _shouldPop;

                internal TerminalScope(ParserState state, Boolean shouldPop)
                {
                    _state = state;
                    _shouldPop = shouldPop;
                }

                public void Dispose()
                {
                    _state.LeaveTerminal(_shouldPop);
                }
            }

            public void ReportError(String message, Int32 position)
            {
                if ((position >= _lastErrorPosition) && (position < TextLength))
                {
                    if (position > _lastErrorPosition)
                        NoError(position);
                    if (!_errorExpectations.Contains(message))
                        _errorExpectations.Add(message);
                    _lastErrorPosition = position;
                }
            }

            public void NoError(Int32 position)
            {
                if (position >= _lastErrorPosition)
                    _errorExpectations.Clear();
            }
        }

        private static String DescribeLiteral(String value)
        {
            if (value.Length == 0)
                return "\"\"";

            StringBuilder builder = new StringBuilder(value.Length + 2);
            builder.Append('\"');
            foreach (Char character in value)
            {
                builder.Append(EscapeCharacter(character));
            }
            builder.Append('\"');
            return builder.ToString();
        }

        private static String DescribeCharacter(Char value) => $"'{EscapeCharacter(value)}'";

        private static String DescribePattern(String value)
        {
            StringBuilder builder = new StringBuilder(value.Length + 2);
            builder.Append('/');
            foreach (Char character in value)
            {
                builder.Append(EscapeCharacter(character));
            }
            builder.Append('/');
            return builder.ToString();
        }

        private static String EscapeCharacter(Char value)
        {
            return value switch
            {
                '\r' => "\\r",
                '\n' => "\\n",
                '\t' => "\\t",
                '\\' => "\\\\",
                '"' => "\\\"",
                '\'' => "\\'",
                _ when Char.IsControl(value) => $"\\x{((Int32)value):X2}",
                _ => value.ToString()
            };
        }

        private Boolean CheckRegEx(ASTNode parentNode, ParserState state, String? errorName, String regEx, Int32 quantifier)
        {
            Int32 oldPosition = state.Position;
            if ((state.Position < state.Text.Length) && (Regex.Match(state.Text.Substring(state.Position, quantifier), $"{regEx}{{{quantifier}}}") is Match regexMatch) && regexMatch.Success)
            {
                state.Position += regexMatch.Length;
                parentNode.AddChild(new ASTNode(-1, "REGEX", state.Text.Substring(oldPosition, state.Position - oldPosition), state.Position));
                state.NoError(state.Position);
                return true;
            }

            Int32 failurePosition = state.Position < state.Text.Length ? state.Position : state.Text.Length;
            state.Position = oldPosition;
            String actual = failurePosition < state.Text.Length
                ? $"found {DescribeCharacter(state.Text[failurePosition])}"
                : "found end of input";
            state.ReportError($"Expected input matching regex {DescribePattern(regEx)}, {actual}", oldPosition);
            return false;
        }

        private Boolean CheckText(ASTNode parentNode, ParserState state, String? errorName, String text)
        {
            Int32 oldPosition = state.Position;
            Int32 position = 0;
            while (position < text.Length)
            {
                if (state.Eof || (state.Text[state.Position] != text[position]))
                {
                    Int32 failurePosition = state.Position < state.Text.Length ? state.Position : state.Text.Length;
                    state.Position = oldPosition;
                    String actual = failurePosition < state.Text.Length
                        ? $"found {DescribeLiteral(state.Text.Substring(oldPosition, failurePosition - oldPosition + 1))}"
                        : "found end of input";
                    state.ReportError($"Expected {DescribeLiteral(text)}, {actual}", oldPosition);
                    return false;
                }
                position++;
                state.Position++;
            }
            parentNode.AddChild(new ASTNode(-1, "TEXT", state.Text.Substring(oldPosition, state.Position - oldPosition), state.Position));
            state.NoError(state.Position);
            return true;
        }

        private Boolean CheckAnd(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> leftCheck, Func<ASTNode, Boolean> rightCheck)
        {
            Int32 oldPosition = state.Position;
            ASTNode tempNode = new ASTNode(parentNode.TokenId, "AND", parentNode.Text, state.Position);
            tempNode.Position = parentNode.Position;
            if (leftCheck(tempNode))
            {
                if (rightCheck(tempNode))
                {
                    parentNode.AddChild(tempNode);
                    parentNode.AssignFrom(tempNode);
                    return true;
                }
            }
            state.Position = oldPosition;
            return false;
        }

        private Boolean CheckOr(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> leftCheck, Func<ASTNode, Boolean> rightCheck)
        {
            Int32 oldPosition = state.Position;
            if (leftCheck(parentNode))
                return true;
            state.Position = oldPosition;
            return rightCheck(parentNode);
        }

        private Boolean Drop(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> check)
        {
            ASTNode tempNode = new ASTNode(-1, "", "", state.Position);
            return check(tempNode);
        }

        private Boolean CheckOneOrMore(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> check)
        {
            Int32 oldPosition = state.Position;
            if (!check(parentNode))
                return false;

            oldPosition = state.Position;
            while (!state.Eof)
            {
                Int32 snapshot = state.Position;
                if (!check(parentNode))
                {
                    state.Position = snapshot;
                    break;
                }
                if (state.Position == snapshot)
                    break;
                oldPosition = state.Position;
            }
            state.Position = oldPosition;
            return true;
        }

        private Boolean CheckZeroOrMore(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> check)
        {
            Int32 lastSuccessfulPosition = state.Position;
            while ((!state.Eof))
            {
                Int32 snapshot = state.Position;
                if (!check(parentNode))
                {
                    state.Position = snapshot;
                    break;
                }
                if (state.Position == snapshot)
                    break;
                lastSuccessfulPosition = state.Position;
            }
            state.Position = lastSuccessfulPosition;
            return true;
        }

        private Boolean CheckDifference(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> leftCheck, Func<ASTNode, Boolean> rightCheck)
        {
            Int32 oldPosition = state.Position;
            if (leftCheck(parentNode))
            {
                state.Position = oldPosition;
                if (rightCheck(parentNode))
                    return true;
            }
            state.Position = oldPosition;
            return false;
        }

        private Boolean CheckRange(ASTNode parentNode, ParserState state, String? errorName, Int32 minCount, Int32 maxCount, Func<ASTNode, Boolean> check)
        {
            Int32 oldPosition = state.Position;
            Int32 count = 0;

            while (count < minCount)
            {
                if (!check(parentNode))
                {
                    state.Position = oldPosition;
                    return false;
                }
                count++;
                oldPosition = state.Position;
            }

            while ((count < maxCount) && !state.Eof)
            {
                Int32 snapshot = state.Position;
                if (!check(parentNode))
                {
                    state.Position = snapshot;
                    break;
                }
                if (state.Position == snapshot)
                    break;
                count++;
                oldPosition = state.Position;
            }

            state.Position = oldPosition;
            return true;
        }

        private Boolean MakeTerminal(ASTNode parentNode, ParserState state, String? errorName, Boolean doNotEscape, Func<ASTNode, Boolean> check)
        {
            Int32 oldPosition = state.Position;
            using (state.EnterTerminal(parentNode.Name))
            {
                ASTNode tempNode = new ASTNode(-1, "", "", state.Position);
                Boolean result = check(tempNode);
                if (result)
                {
                    tempNode.Text = tempNode.GetText();
                    tempNode.ClearChildren();
                    parentNode.Text = tempNode.GetText();
                    if (doNotEscape)
                        parentNode.Text = Regex.Unescape(parentNode.Text);
                }
                return result;
            }
        }

        private Boolean PromoteAction(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, Boolean> check)
        {
            Int32 childCount = parentNode.Children.Count;
            Boolean result = check(parentNode);
            if (result && (childCount < parentNode.Children.Count))
            {
                ASTNode newNode = parentNode.Children.Last();
                parentNode.AssignFrom(newNode);
            }
            return result;
        }

        private Boolean AddVirtualNode(ASTNode parentNode, ParserState state, String? errorName, Int32 tokenId, String text)
        {
            parentNode.AddChild(new ASTNode(tokenId, "VIRTUAL", text, state.Position));
            return true;
        }

        private Boolean CheckRule_BracketClose(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(0, "BracketClose", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, ")"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_BracketContent(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(20, "BracketContent", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckText(actualNode, state, errorName, "\\"),
                        (actualNode) => CheckRegEx(actualNode, state, errorName, "[.\\\\\\[\\]-^]", 1)
                    ),
                    (actualNode) => CheckOr(actualNode, state, errorName,
                        (actualNode) => CheckRegEx(actualNode, state, errorName, "[^\\[\\\\\\]]", 1),
                        (actualNode) => CheckOr(actualNode, state, errorName,
                            (actualNode) => CheckRule_EscapeChars(actualNode, state, errorName),
                            (actualNode) => CheckRule_UnicodeChars(actualNode, state, errorName)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_BracketOpen(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(1, "BracketOpen", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "("),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_CSharpIdentCont(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(25, "CSharpIdentCont", "", state.Position);
            Boolean result =
                CheckZeroOrMore(actualNode, state, errorName,
                    (actualNode) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z0-9_.]", 1)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_CSharpIdentifier(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(26, "CSharpIdentifier", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRule_IdentStart(actualNode, state, errorName),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_CSharpIdentCont(actualNode, state, errorName),
                            (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Char(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(23, "Char", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode) => CheckRegEx(actualNode, state, errorName, "[^'\\\\]", 1),
                    (actualNode) => CheckOr(actualNode, state, errorName,
                        (actualNode) => CheckText(actualNode, state, errorName, "\\'"),
                        (actualNode) => CheckOr(actualNode, state, errorName,
                            (actualNode) => CheckText(actualNode, state, errorName, "\\\\"),
                            (actualNode) => CheckOr(actualNode, state, errorName,
                                (actualNode) => CheckRule_EscapeChars(actualNode, state, errorName),
                                (actualNode) => CheckRule_UnicodeChars(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_ClassName(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(38, "ClassName", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => Drop(actualNode, state, errorName,
                            (actualNode) => CheckText(actualNode, state, errorName, "@class")
                        ),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => CheckRule_CSharpIdentifier(actualNode, state, errorName),
                                (actualNode) => CheckRule_LineEnd(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Comment(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(2, "Comment", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "#"),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckZeroOrMore(actualNode, state, errorName,
                            (actualNode) => CheckRegEx(actualNode, state, errorName, "[^\\r\\n]", 1)
                        ),
                        (actualNode) => CheckRegEx(actualNode, state, errorName, "[\\r\\n]", 1)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Config(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(40, "Config", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Namespace(actualNode, state, errorName),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRule_ClassName(actualNode, state, errorName),
                        (actualNode) => CheckRule_RootNode(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Definition(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(36, "Definition", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode) => CheckOr(actualNode, state, errorName,
                                (actualNode) => CheckRule_IsTerminal(actualNode, state, errorName),
                                (actualNode) => CheckOr(actualNode, state, errorName,
                                    (actualNode) => CheckRule_Drop(actualNode, state, errorName),
                                    (actualNode) => CheckRule_TreatInline(actualNode, state, errorName)
                                )
                            )
                        ),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_Identifier(actualNode, state, errorName),
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => Drop(actualNode, state, errorName,
                                    (actualNode) => CheckRule_Equal(actualNode, state, errorName)
                                ),
                                (actualNode) => CheckAnd(actualNode, state, errorName,
                                    (actualNode) => CheckRule_Expression(actualNode, state, errorName),
                                    (actualNode) => CheckRule_LineEnd(actualNode, state, errorName)
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Dot(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(7, "Dot", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "."),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Drop(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(14, "Drop", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "-"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Equal(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(9, "Equal", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "="),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_EscapeChars(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(11, "EscapeChars", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "\\"),
                    (actualNode) => CheckRegEx(actualNode, state, errorName, "[\\\\0abfnrtv\"'?]", 1)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Expression(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(34, "Expression", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Sequence(actualNode, state, errorName),
                    (actualNode) => CheckZeroOrMore(actualNode, state, errorName,
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_Or(actualNode, state, errorName),
                            (actualNode) => CheckRule_Sequence(actualNode, state, errorName)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Grammar(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(41, "Grammar", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Config(actualNode, state, errorName),
                    (actualNode) => CheckOneOrMore(actualNode, state, errorName,
                        (actualNode) => CheckRule_Definition(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_IdentCont(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(27, "IdentCont", "", state.Position);
            Boolean result =
                CheckZeroOrMore(actualNode, state, errorName,
                    (actualNode) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z0-9_]", 1)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_IdentStart(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(28, "IdentStart", "", state.Position);
            Boolean result =         CheckRegEx(actualNode, state, errorName, "[a-zA-Z_]", 1);
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Identifier(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(29, "Identifier", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRule_IdentStart(actualNode, state, errorName),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_IdentCont(actualNode, state, errorName),
                            (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_IsTerminal(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(13, "IsTerminal", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "$"),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode) => CheckText(actualNode, state, errorName, "$")
                        ),
                        (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_LineEnd(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(8, "LineEnd", "", state.Position);
            Boolean result =
                Drop(actualNode, state, errorName,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                        (actualNode) => CheckText(actualNode, state, errorName, ";")
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Literal(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(24, "Literal", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckOr(actualNode, state, errorName,
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => Drop(actualNode, state, errorName,
                                    (actualNode) => CheckText(actualNode, state, errorName, "'")
                                ),
                                (actualNode) => CheckAnd(actualNode, state, errorName,
                                    (actualNode) => CheckZeroOrMore(actualNode, state, errorName,
                                        (actualNode) => CheckRule_Char(actualNode, state, errorName)
                                    ),
                                    (actualNode) => Drop(actualNode, state, errorName,
                                        (actualNode) => CheckText(actualNode, state, errorName, "'")
                                    )
                                )
                            ),
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => CheckText(actualNode, state, errorName, "\""),
                                (actualNode) => CheckAnd(actualNode, state, errorName,
                                    (actualNode) => CheckZeroOrMore(actualNode, state, errorName,
                                        (actualNode) => CheckRule_Char(actualNode, state, errorName)
                                    ),
                                    (actualNode) => CheckText(actualNode, state, errorName, "\"")
                                )
                            )
                        ),
                        (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Namespace(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(39, "Namespace", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => Drop(actualNode, state, errorName,
                            (actualNode) => CheckText(actualNode, state, errorName, "@namespace")
                        ),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => CheckRule_CSharpIdentifier(actualNode, state, errorName),
                                (actualNode) => CheckRule_LineEnd(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_NewLine(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(4, "NewLine", "", state.Position);
            Boolean result =         CheckRegEx(actualNode, state, errorName, "[\\r]", 1);
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Number(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(3, "Number", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode) => CheckOr(actualNode, state, errorName,
                        (actualNode) => CheckText(actualNode, state, errorName, "0"),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRegEx(actualNode, state, errorName, "[1-9]", 1),
                            (actualNode) => CheckZeroOrMore(actualNode, state, errorName,
                                (actualNode) => CheckRegEx(actualNode, state, errorName, "[0-9]", 1)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_OneOrMore(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(15, "OneOrMore", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "+"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Optional(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(17, "Optional", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "?"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Or(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(18, "Or", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "/"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Prefix(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(32, "Prefix", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRange(actualNode, state, errorName, 0, 1,
                        (actualNode) => CheckRule_Drop(actualNode, state, errorName)
                    ),
                    (actualNode) => CheckRule_Suffix(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Primary(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(30, "Primary", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode) => CheckRule_Identifier(actualNode, state, errorName),
                    (actualNode) => CheckOr(actualNode, state, errorName,
                        (actualNode) => CheckRule_Literal(actualNode, state, errorName),
                        (actualNode) => CheckOr(actualNode, state, errorName,
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => Drop(actualNode, state, errorName,
                                    (actualNode) => CheckRule_BracketOpen(actualNode, state, errorName)
                                ),
                                (actualNode) => CheckAnd(actualNode, state, errorName,
                                    (actualNode) => CheckRule_Expression(actualNode, state, errorName),
                                    (actualNode) => Drop(actualNode, state, errorName,
                                        (actualNode) => CheckRule_BracketClose(actualNode, state, errorName)
                                    )
                                )
                            ),
                            (actualNode) => CheckOr(actualNode, state, errorName,
                                (actualNode) => CheckRule_Regex(actualNode, state, errorName),
                                (actualNode) => CheckRule_Dot(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Regex(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(22, "Regex", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_RegularExpression(actualNode, state, errorName),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => CheckText(actualNode, state, errorName, "{"),
                                (actualNode) => CheckAnd(actualNode, state, errorName,
                                    (actualNode) => CheckRule_Number(actualNode, state, errorName),
                                    (actualNode) => CheckText(actualNode, state, errorName, "}")
                                )
                            )
                        ),
                        (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_RegularExpression(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(21, "RegularExpression", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckText(actualNode, state, errorName, "["),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckOneOrMore(actualNode, state, errorName,
                                (actualNode) => CheckRule_BracketContent(actualNode, state, errorName)
                            ),
                            (actualNode) => CheckText(actualNode, state, errorName, "]")
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_RootNode(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(37, "RootNode", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => Drop(actualNode, state, errorName,
                            (actualNode) => CheckText(actualNode, state, errorName, "@rootnode")
                        ),
                        (actualNode) => CheckAnd(actualNode, state, errorName,
                            (actualNode) => CheckRule_Spacing(actualNode, state, errorName),
                            (actualNode) => CheckAnd(actualNode, state, errorName,
                                (actualNode) => CheckRule_Identifier(actualNode, state, errorName),
                                (actualNode) => CheckRule_LineEnd(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Sequence(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(33, "Sequence", "", state.Position);
            Boolean result =
                CheckZeroOrMore(actualNode, state, errorName,
                    (actualNode) => CheckRule_Prefix(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Spacing(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(6, "Spacing", "", state.Position);
            Boolean result =
                Drop(actualNode, state, errorName,
                    (actualNode) => CheckZeroOrMore(actualNode, state, errorName,
                        (actualNode) => CheckOr(actualNode, state, errorName,
                            (actualNode) => CheckRule_NewLine(actualNode, state, errorName),
                            (actualNode) => CheckOr(actualNode, state, errorName,
                                (actualNode) => CheckRule_WhiteSpace(actualNode, state, errorName),
                                (actualNode) => CheckRule_Comment(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Suffix(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(31, "Suffix", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckRule_Primary(actualNode, state, errorName),
                    (actualNode) => CheckRange(actualNode, state, errorName, 0, 1,
                        (actualNode) => CheckOr(actualNode, state, errorName,
                            (actualNode) => CheckRule_Optional(actualNode, state, errorName),
                            (actualNode) => CheckOr(actualNode, state, errorName,
                                (actualNode) => CheckRule_ZeroOrMore(actualNode, state, errorName),
                                (actualNode) => CheckRule_OneOrMore(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TreatInline(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(12, "TreatInline", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, ":"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_UnicodeChars(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(10, "UnicodeChars", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, true,
                    (actualNode) => CheckAnd(actualNode, state, errorName,
                        (actualNode) => CheckText(actualNode, state, errorName, "\\u"),
                        (actualNode) => CheckRegEx(actualNode, state, errorName, "[0-9a-fA-F]", 4)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_WhiteSpace(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(5, "WhiteSpace", "", state.Position);
            Boolean result =         CheckRegEx(actualNode, state, errorName, "[ \\t\\r\\n]", 1);
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_ZeroOrMore(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(16, "ZeroOrMore", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode) => CheckText(actualNode, state, errorName, "*"),
                    (actualNode) => CheckRule_Spacing(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

    }
}