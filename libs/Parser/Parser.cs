//****************************************//
//*                                      *//
//* This code is generated by parseidon. *//
//*     https://github.com/parseidon     *//
//*                                      *//
//****************************************//

using System.Text.RegularExpressions;

namespace Parseidon.Parser;

public class ParseidonParser
{
    public class Visitor
    {
        public virtual void OnRuleGrammar(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleSpacing(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleNewLine(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleWhiteSpace(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleComment(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleDefinition(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleIsTerminal(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleDrop(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleIdentifier(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleIdentStart(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleIdentCont(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleEqual(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleExpression(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleSequence(ParseidonParser.ASTNode node) {}
        public virtual void OnRulePrefix(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleSuffix(ParseidonParser.ASTNode node) {}
        public virtual void OnRulePrimary(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleLiteral(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleChar(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleEscapeChars(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleBracketOpen(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleBracketClose(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleRegex(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleNumber(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleDot(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleOptional(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleZeroOrMore(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleOneOrMore(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleOr(ParseidonParser.ASTNode node) {}
        public virtual void OnRuleLineEnd(ParseidonParser.ASTNode node) {}
        public virtual void Visit(ASTNode node)
        {
            if(node == null)
                return;
            foreach(ASTNode child in node.Children)
                Visit(child);
            CallEvent(node.TokenId, node);
        }
    
        public virtual void CallEvent(Int32 tokenId, ASTNode node)
        {
            switch(tokenId)
            {
                case 29: OnRuleGrammar(node); break;
                case 6: OnRuleSpacing(node); break;
                case 4: OnRuleNewLine(node); break;
                case 5: OnRuleWhiteSpace(node); break;
                case 2: OnRuleComment(node); break;
                case 28: OnRuleDefinition(node); break;
                case 11: OnRuleIsTerminal(node); break;
                case 12: OnRuleDrop(node); break;
                case 22: OnRuleIdentifier(node); break;
                case 21: OnRuleIdentStart(node); break;
                case 20: OnRuleIdentCont(node); break;
                case 9: OnRuleEqual(node); break;
                case 27: OnRuleExpression(node); break;
                case 26: OnRuleSequence(node); break;
                case 25: OnRulePrefix(node); break;
                case 24: OnRuleSuffix(node); break;
                case 23: OnRulePrimary(node); break;
                case 19: OnRuleLiteral(node); break;
                case 18: OnRuleChar(node); break;
                case 10: OnRuleEscapeChars(node); break;
                case 1: OnRuleBracketOpen(node); break;
                case 0: OnRuleBracketClose(node); break;
                case 17: OnRuleRegex(node); break;
                case 3: OnRuleNumber(node); break;
                case 7: OnRuleDot(node); break;
                case 15: OnRuleOptional(node); break;
                case 14: OnRuleZeroOrMore(node); break;
                case 13: OnRuleOneOrMore(node); break;
                case 16: OnRuleOr(node); break;
                case 8: OnRuleLineEnd(node); break;
            }
        }
    }

    private ASTNode? rootNode = null;
    
    public class ASTNode
    {
        private List<ASTNode> _children { get; } = new List<ASTNode>();
        private ASTNode? _parent = null;
    
        public String Text { get; set; }
        public String Name { get; set; }
        public IReadOnlyList<ASTNode> Children { get => _children; } 
        public Int32 TokenId { get; private set; }
        public Int32 Position { get; set; }
        public ASTNode? Parent { get => _parent; }            
    
        public ASTNode(Int32 tokenId, String name, String text)
        {
            Text = text;
            TokenId = tokenId;
            Name = name;
        }
    
        public void AssignFrom(ASTNode node)
        {
            Int32 nodeIndex = _children.IndexOf(node);
            if (nodeIndex >= 0)
            {
                Text = node.Text;
                TokenId = node.TokenId;
                Position = node.Position;
                List<ASTNode> tempChildren = new List<ASTNode>(node.Children);
                foreach(ASTNode child in tempChildren)
                {
                    child.SetParent(this, nodeIndex);
                    nodeIndex++;
                }
                _children.Remove(node);
            }
        }
         
        public String GetText()
        {
            if (Children.Count > 0)
                return String.Join("", Children.Select(x => x.GetText()));
            else
                return Text;
        }
    
        public void SetParent(ASTNode? parent, Int32 index = -1)
        {
            if(_parent != null)
                _parent._children.Remove(this);
            _parent = parent;
            if(_parent != null)
            {
                if(index < 0)
                    _parent._children.Add(this);
                else
                    _parent._children.Insert(index, this);
            }
        }
        
        public void AddChild(ASTNode? child)
        {
            if(child != null)
                _children.Add(child);
        }
    
        public void ClearChildren()
        {
            _children.Clear();
        }            
    }
    
    public class ParserState
    {
        public ParserState(String text)
        {
            Text = text;
        }            
        public String Text { get; }
        public Int32 Position { get; set; } = 0;
        public Boolean Eof => !(Position < Text.Length);
    }
    
    public Boolean CheckRegEx(ASTNode parentNode, ParserState state, String regEx)
    {
        Int32 oldPosition = state.Position;
        if((state.Position < state.Text.Length) && Regex.Match(state.Text[state.Position].ToString(), regEx).Success)
        {
            state.Position++;
            parentNode.AddChild(new ASTNode(-1, "REGEX", state.Text.Substring(oldPosition, state.Position - oldPosition)));
            return true;
        }
        state.Position = oldPosition;
        return false;
    }
    
    public Boolean CheckText(ASTNode parentNode, ParserState state, String text)
    {
        Int32 oldPosition = state.Position;
        Int32 position = 0;
        while (position < text.Length)
        {
            if(state.Eof || (state.Text[state.Position] != text[position]))
            {
                state.Position = oldPosition;
                return false;
            }
            position++;
            state.Position++;
        }
        parentNode.AddChild(new ASTNode(-1, "TEXT", state.Text.Substring(oldPosition, state.Position - oldPosition)));
        return true;
    }
    
    public Boolean CheckAnd(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> leftCheck, Func<ASTNode, Boolean> rightCheck)
    {
        Int32 oldPosition = state.Position;
        ASTNode tempNode = new ASTNode(parentNode.TokenId, "AND", parentNode.Text);
        tempNode.Position = parentNode.Position;
        if(leftCheck(tempNode))
        {
            if(rightCheck(tempNode))
            {
                parentNode.AddChild(tempNode);
                parentNode.AssignFrom(tempNode);
                return true;
            }
        }
        state.Position = oldPosition;
        return false;
    }
    
    public Boolean CheckOr(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> leftCheck, Func<ASTNode, Boolean> rightCheck)
    {
        Int32 oldPosition = state.Position;
        if(leftCheck(parentNode))
            return true;
        if(rightCheck(parentNode))
            return true;
        state.Position = oldPosition;
        return false;
    }
    
    public Boolean Drop(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> check)
    {
        Int32 oldPosition = state.Position;
        ASTNode tempNode = new ASTNode(-1, "", "");
        return check(tempNode);
    }
    
    public Boolean CheckOneOrMore(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> check)
    {
        Int32 oldPosition = state.Position;
        if(check(parentNode))
        {
            oldPosition = state.Position;
            while(check(parentNode))
            {
                oldPosition = state.Position;
            }
            state.Position = oldPosition;
            return true;
        }
        state.Position = oldPosition;
        return false;
    }
    
    public Boolean CheckZeroOrMore(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> check)
    {
        Int32 oldPosition = state.Position;
        while((!state.Eof) && check(parentNode))
        {
            oldPosition = state.Position;
        }
        state.Position = oldPosition;
        return true;
    }
    
    public Boolean CheckDifference(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> leftCheck, Func<ASTNode, Boolean> rightCheck)
    {
        Int32 oldPosition = state.Position;
        if(leftCheck(parentNode))
        {
            state.Position = oldPosition;
            if(rightCheck(parentNode))
                return true;
        }
        state.Position = oldPosition;
        return false;
    }
    
    public Boolean CheckRange(ASTNode parentNode, ParserState state, Int32 minCount, Int32 maxCount, Func<ASTNode, Boolean> check)
    {
        Int32 oldPosition = state.Position;
        Int32 count = 0;
        while((count <= maxCount) && check(parentNode))
        {
            oldPosition = state.Position;
            count++;
        }
        if(count >= minCount)
            return true;
        state.Position = oldPosition;
        return true;
    }
    
    public Boolean MakeTerminal(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> check)
    {
        Int32 oldPosition = state.Position;
        ASTNode tempNode = new ASTNode(-1, "", "");
        Boolean result =  check(tempNode);
        if (result)
        {
            tempNode.Text = tempNode.GetText();
            tempNode.ClearChildren();
            parentNode.Text = tempNode.GetText();
        }
        return result;
    }
    
    public Boolean PromoteAction(ASTNode parentNode, ParserState state, Func<ASTNode, Boolean> check)
    {
        Int32 childCount = parentNode.Children.Count;
        Boolean result = check(parentNode);
        if(result && (childCount < parentNode.Children.Count))
        {
            ASTNode newNode = parentNode.Children.Last();
            parentNode.AssignFrom(newNode);
        }
        return result;
    }
    
    public Boolean AddVirtualNode(ASTNode parentNode, ParserState state, Int32 tokenId, String text)
    {
        parentNode.AddChild(new ASTNode(tokenId, "VIRTUAL", text));
        return true;
    }
    
    public void Visit(Visitor visitor)
    {
        if(rootNode == null)
            throw new Exception("Root node is null");
        visitor.Visit(rootNode);
    }

    public Boolean CheckRule_Grammar(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(29, "Grammar", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckRule_Spacing(actualNode, state),
                (actualNode) => CheckOneOrMore(actualNode, state, 
                    (actualNode) => CheckRule_Definition(actualNode, state)
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Spacing(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(6, "Spacing", "");
        Boolean result =         
            Drop(actualNode, state, 
                (actualNode) => CheckZeroOrMore(actualNode, state, 
                    (actualNode) => CheckOr(actualNode, state, 
                        (actualNode) => CheckRule_NewLine(actualNode, state),
                        (actualNode) => CheckOr(actualNode, state, 
                            (actualNode) => CheckRule_WhiteSpace(actualNode, state),
                            (actualNode) => CheckRule_Comment(actualNode, state)
                        )
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_NewLine(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(4, "NewLine", "");
        Boolean result =         CheckRegEx(actualNode, state, "[\\r]");
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_WhiteSpace(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(5, "WhiteSpace", "");
        Boolean result =         CheckRegEx(actualNode, state, "[ \\t\\r\\n]");
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Comment(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(2, "Comment", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "#"),
                (actualNode) => CheckAnd(actualNode, state, 
                    (actualNode) => CheckZeroOrMore(actualNode, state, 
                        (actualNode) => CheckAnd(actualNode, state, 
                            (actualNode) => Drop(actualNode, state, 
                                (actualNode) => CheckRegEx(actualNode, state, "[\\r\\n]")
                            ),
                            (actualNode) => CheckRegEx(actualNode, state, ".")
                        )
                    ),
                    (actualNode) => CheckRegEx(actualNode, state, "[\\r\\n]")
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Definition(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(28, "Definition", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckRule_Spacing(actualNode, state),
                (actualNode) => CheckAnd(actualNode, state, 
                    (actualNode) => CheckRange(actualNode, state, 0, 1,
                        (actualNode) => CheckOr(actualNode, state, 
                            (actualNode) => CheckRule_IsTerminal(actualNode, state),
                            (actualNode) => CheckRule_Drop(actualNode, state)
                        )
                    ),
                    (actualNode) => CheckAnd(actualNode, state, 
                        (actualNode) => CheckRule_Identifier(actualNode, state),
                        (actualNode) => CheckAnd(actualNode, state, 
                            (actualNode) => Drop(actualNode, state, 
                                (actualNode) => CheckRule_Equal(actualNode, state)
                            ),
                            (actualNode) => CheckAnd(actualNode, state, 
                                (actualNode) => CheckRule_Expression(actualNode, state),
                                (actualNode) => CheckRule_LineEnd(actualNode, state)
                            )
                        )
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_IsTerminal(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(11, "IsTerminal", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "$"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Drop(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(12, "Drop", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "!"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Identifier(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(22, "Identifier", "");
        Boolean result =         
            MakeTerminal(actualNode, state, 
                (actualNode) => CheckAnd(actualNode, state, 
                    (actualNode) => CheckRule_IdentStart(actualNode, state),
                    (actualNode) => CheckAnd(actualNode, state, 
                        (actualNode) => CheckRule_IdentCont(actualNode, state),
                        (actualNode) => CheckRule_Spacing(actualNode, state)
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_IdentStart(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(21, "IdentStart", "");
        Boolean result =         CheckRegEx(actualNode, state, "[a-zA-Z_]");
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_IdentCont(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(20, "IdentCont", "");
        Boolean result =         
            CheckZeroOrMore(actualNode, state, 
                (actualNode) => CheckRegEx(actualNode, state, "[a-zA-Z0-9_]")
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Equal(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(9, "Equal", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "="),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Expression(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(27, "Expression", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckRule_Sequence(actualNode, state),
                (actualNode) => CheckZeroOrMore(actualNode, state, 
                    (actualNode) => CheckAnd(actualNode, state, 
                        (actualNode) => CheckRule_Or(actualNode, state),
                        (actualNode) => CheckRule_Sequence(actualNode, state)
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Sequence(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(26, "Sequence", "");
        Boolean result =         
            CheckZeroOrMore(actualNode, state, 
                (actualNode) => CheckRule_Prefix(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Prefix(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(25, "Prefix", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckRange(actualNode, state, 0, 1,
                    (actualNode) => CheckRule_Drop(actualNode, state)
                ),
                (actualNode) => CheckRule_Suffix(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Suffix(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(24, "Suffix", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckRule_Primary(actualNode, state),
                (actualNode) => CheckRange(actualNode, state, 0, 1,
                    (actualNode) => CheckOr(actualNode, state, 
                        (actualNode) => CheckRule_Optional(actualNode, state),
                        (actualNode) => CheckOr(actualNode, state, 
                            (actualNode) => CheckRule_ZeroOrMore(actualNode, state),
                            (actualNode) => CheckRule_OneOrMore(actualNode, state)
                        )
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Primary(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(23, "Primary", "");
        Boolean result =         
            CheckOr(actualNode, state, 
                (actualNode) => CheckRule_Identifier(actualNode, state),
                (actualNode) => CheckOr(actualNode, state, 
                    (actualNode) => CheckRule_Literal(actualNode, state),
                    (actualNode) => CheckOr(actualNode, state, 
                        (actualNode) => CheckAnd(actualNode, state, 
                            (actualNode) => Drop(actualNode, state, 
                                (actualNode) => CheckRule_BracketOpen(actualNode, state)
                            ),
                            (actualNode) => CheckAnd(actualNode, state, 
                                (actualNode) => CheckRule_Expression(actualNode, state),
                                (actualNode) => Drop(actualNode, state, 
                                    (actualNode) => CheckRule_BracketClose(actualNode, state)
                                )
                            )
                        ),
                        (actualNode) => CheckOr(actualNode, state, 
                            (actualNode) => CheckRule_Regex(actualNode, state),
                            (actualNode) => CheckRule_Dot(actualNode, state)
                        )
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Literal(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(19, "Literal", "");
        Boolean result =         
            MakeTerminal(actualNode, state, 
                (actualNode) => CheckAnd(actualNode, state, 
                    (actualNode) => CheckOr(actualNode, state, 
                        (actualNode) => CheckAnd(actualNode, state, 
                            (actualNode) => Drop(actualNode, state, 
                                (actualNode) => CheckText(actualNode, state, "'")
                            ),
                            (actualNode) => CheckAnd(actualNode, state, 
                                (actualNode) => CheckZeroOrMore(actualNode, state, 
                                    (actualNode) => CheckRule_Char(actualNode, state)
                                ),
                                (actualNode) => Drop(actualNode, state, 
                                    (actualNode) => CheckText(actualNode, state, "'")
                                )
                            )
                        ),
                        (actualNode) => CheckAnd(actualNode, state, 
                            (actualNode) => CheckText(actualNode, state, "\""),
                            (actualNode) => CheckAnd(actualNode, state, 
                                (actualNode) => CheckZeroOrMore(actualNode, state, 
                                    (actualNode) => CheckRule_Char(actualNode, state)
                                ),
                                (actualNode) => CheckText(actualNode, state, "\"")
                            )
                        )
                    ),
                    (actualNode) => CheckRule_Spacing(actualNode, state)
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Char(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(18, "Char", "");
        Boolean result =         
            CheckOr(actualNode, state, 
                (actualNode) => CheckRegEx(actualNode, state, "[^'\\\\]"),
                (actualNode) => CheckOr(actualNode, state, 
                    (actualNode) => CheckText(actualNode, state, "\\'"),
                    (actualNode) => CheckOr(actualNode, state, 
                        (actualNode) => CheckText(actualNode, state, "\\\\"),
                        (actualNode) => CheckRule_EscapeChars(actualNode, state)
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_EscapeChars(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(10, "EscapeChars", "");
        Boolean result =         
            CheckOr(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "\\0"),
                (actualNode) => CheckOr(actualNode, state, 
                    (actualNode) => CheckText(actualNode, state, "\\a"),
                    (actualNode) => CheckOr(actualNode, state, 
                        (actualNode) => CheckText(actualNode, state, "\\b"),
                        (actualNode) => CheckOr(actualNode, state, 
                            (actualNode) => CheckText(actualNode, state, "\\f"),
                            (actualNode) => CheckOr(actualNode, state, 
                                (actualNode) => CheckText(actualNode, state, "\\n"),
                                (actualNode) => CheckOr(actualNode, state, 
                                    (actualNode) => CheckText(actualNode, state, "\\r"),
                                    (actualNode) => CheckOr(actualNode, state, 
                                        (actualNode) => CheckText(actualNode, state, "\\t"),
                                        (actualNode) => CheckOr(actualNode, state, 
                                            (actualNode) => CheckText(actualNode, state, "\\v"),
                                            (actualNode) => CheckOr(actualNode, state, 
                                                (actualNode) => CheckAnd(actualNode, state, 
                                                    (actualNode) => CheckText(actualNode, state, "\\u"),
                                                    (actualNode) => CheckRegEx(actualNode, state, "[0-9a-fA-F]{4}")
                                                ),
                                                (actualNode) => CheckAnd(actualNode, state, 
                                                    (actualNode) => CheckText(actualNode, state, "\\u"),
                                                    (actualNode) => CheckRegEx(actualNode, state, "[0-9a-fA-F]{8}")
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_BracketOpen(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(1, "BracketOpen", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "("),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_BracketClose(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(0, "BracketClose", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, ")"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Regex(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(17, "Regex", "");
        Boolean result =         
            MakeTerminal(actualNode, state, 
                (actualNode) => CheckAnd(actualNode, state, 
                    (actualNode) => CheckText(actualNode, state, "["),
                    (actualNode) => CheckAnd(actualNode, state, 
                        (actualNode) => CheckOneOrMore(actualNode, state, 
                            (actualNode) => CheckOr(actualNode, state, 
                                (actualNode) => CheckRegEx(actualNode, state, "[^\\\\\\[\\]]"),
                                (actualNode) => CheckOr(actualNode, state, 
                                    (actualNode) => CheckText(actualNode, state, "\\["),
                                    (actualNode) => CheckOr(actualNode, state, 
                                        (actualNode) => CheckText(actualNode, state, "\\]"),
                                        (actualNode) => CheckOr(actualNode, state, 
                                            (actualNode) => CheckText(actualNode, state, "\\-"),
                                            (actualNode) => CheckOr(actualNode, state, 
                                                (actualNode) => CheckText(actualNode, state, "\\^"),
                                                (actualNode) => CheckOr(actualNode, state, 
                                                    (actualNode) => CheckText(actualNode, state, "\\\\"),
                                                    (actualNode) => CheckRule_EscapeChars(actualNode, state)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        (actualNode) => CheckAnd(actualNode, state, 
                            (actualNode) => CheckText(actualNode, state, "]"),
                            (actualNode) => CheckAnd(actualNode, state, 
                                (actualNode) => CheckRange(actualNode, state, 0, 1,
                                    (actualNode) => CheckAnd(actualNode, state, 
                                        (actualNode) => CheckText(actualNode, state, "{"),
                                        (actualNode) => CheckAnd(actualNode, state, 
                                            (actualNode) => CheckRule_Number(actualNode, state),
                                            (actualNode) => CheckText(actualNode, state, "}")
                                        )
                                    )
                                ),
                                (actualNode) => CheckRule_Spacing(actualNode, state)
                            )
                        )
                    )
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Number(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(3, "Number", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckRegEx(actualNode, state, "[1-9]"),
                (actualNode) => CheckZeroOrMore(actualNode, state, 
                    (actualNode) => CheckRegEx(actualNode, state, "[0-9]")
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Dot(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(7, "Dot", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "."),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Optional(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(15, "Optional", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "?"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_ZeroOrMore(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(14, "ZeroOrMore", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "*"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_OneOrMore(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(13, "OneOrMore", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "+"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_Or(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(16, "Or", "");
        Boolean result =         
            CheckAnd(actualNode, state, 
                (actualNode) => CheckText(actualNode, state, "/"),
                (actualNode) => CheckRule_Spacing(actualNode, state)
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }
    public Boolean CheckRule_LineEnd(ASTNode parentNode, ParserState state)
    {
        Int32 oldPosition = state.Position;
        ASTNode actualNode = new ASTNode(8, "LineEnd", "");
        Boolean result =         
            Drop(actualNode, state, 
                (actualNode) => CheckAnd(actualNode, state, 
                    (actualNode) => CheckRule_Spacing(actualNode, state),
                    (actualNode) => CheckText(actualNode, state, ";")
                )
            );
        Int32 foundPosition = state.Position;
        if(result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
            parentNode.AddChild(actualNode);
        return result;
    }

    public void Parse(String text)
    {
        ParserState state = new ParserState(text);
        ASTNode actualNode = new ASTNode(-1, "ROOT", "");            
        if(CheckRule_Grammar(actualNode, state))
            rootNode = actualNode;
    }
}