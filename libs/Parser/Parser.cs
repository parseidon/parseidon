//****************************************//
//*                                      *//
//* This code is generated by parseidon. *//
//*     https://github.com/parseidon     *//
//*                                      *//
//*         2025-12-08 17:32:25          *//
//*                                      *//
//****************************************//

#nullable enable

using System.Text;
using System.Text.RegularExpressions;

namespace Parseidon.Parser
{
    public interface IVisitResult
    {
        Boolean Successful { get; }
        IReadOnlyList<ParserMessage> Messages { get; }
    }

    public interface IVisitor
    {
        Object GetContext(ParseResult parseResult);
        IVisitResult GetResult(Object context, Boolean successful, IReadOnlyList<ParserMessage> messages);
    }

    public interface INodeVisitor : IVisitor
    {
        ProcessNodeResult ProcessAllCharNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessBooleanNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessCSharpIdentifierNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessCharacterClassNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessDefinitionNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessDropNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessExpressionNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessGrammarNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessIdentifierNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessIsTerminalNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessLiteralNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessNumberNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessOneOrMoreNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessOptionalNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessPrefixNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessRegexNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessSequenceNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessSuffixNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMDefinitionNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMIdentifierNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMIncludesNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMMatchNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMMatchSequenceNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMRegExNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTMScopeNameNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessTreatInlineNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessUseRuleNameAsErrorNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessValuePairNode(Object context, ASTNode node, IList<ParserMessage> messages);
        ProcessNodeResult ProcessZeroOrMoreNode(Object context, ASTNode node, IList<ParserMessage> messages);
        void BeginVisit(Object context, ASTNode node);
        void EndVisit(Object context, ASTNode node);
    }

    public enum ProcessNodeResult
    {
        Success,
        Error
    }

    public class MessageContext
    {
        private String _text;
        internal MessageContext(String text)
        {
            _text = text;
        }

        public (UInt32 Row, UInt32 Column) CalculateLocation(Int32 position)
        {
            Int32 row = 1;
            Int32 column = 1;
            Int32 limit = position;
            if (limit > _text.Length)
                limit = _text.Length;

            for (Int32 index = 0; index < limit; index++)
            {
                if (_text[index] == '\n')
                {
                    row++;
                    column = 1;
                }
                else
                {
                    column++;
                }
            }

            return ((UInt32)row, (UInt32)column);
        }
    }

    public class ParseResult
    {
        private class EmptyResult : IVisitResult
        {
            public EmptyResult(Boolean successful, IReadOnlyList<ParserMessage> messages)
            {
                Successful = successful;
                Messages = messages;
            }
            public Boolean Successful { get; }
            public IReadOnlyList<ParserMessage> Messages { get; }
        }

        public ParseResult(ASTNode? rootNode, MessageContext messageContext, IReadOnlyList<ParserMessage> messages)
        {
            RootNode = rootNode;
            MessageContext = messageContext;
            Messages = new List<ParserMessage>(messages);
        }

        public Boolean Successful { get => RootNode is not null; }
        public ASTNode? RootNode { get; }
        public IReadOnlyList<ParserMessage> Messages { get; }
        public MessageContext MessageContext { get; }

        public IVisitResult Visit(IVisitor visitor)
        {
            if (visitor is null)
                throw new ArgumentNullException(nameof(visitor));
            List<ParserMessage> visitMessages = new List<ParserMessage>();
            if (Successful)
            {
                try
                {
                    Object context = visitor.GetContext(this);
                    if (visitor is INodeVisitor)
                        DoVisit(context, (visitor as INodeVisitor)!, RootNode!, visitMessages);
                    return visitor.GetResult(context, true, visitMessages);
                }
                catch (GrammarException ex)
                {
                    visitMessages.Add(new ParserMessage(ex.Message, ParserMessage.MessageType.Error, (ex.Row, ex.Column)));
                }
            }
            return new EmptyResult(false, visitMessages);
        }

        private ProcessNodeResult DoVisit(Object context, INodeVisitor visitor, ASTNode node, IList<ParserMessage> messages)
        {
            visitor.BeginVisit(context, node);
            try
            {
                if (node == null)
                    return ProcessNodeResult.Error;
                Boolean result = true;
                foreach (ASTNode child in node.Children)
                    result = result && (DoVisit(context, visitor, child, messages) == ProcessNodeResult.Success);
                result = result && (CallEvent(context, visitor, node.TokenId, node, messages) == ProcessNodeResult.Success);
                return result ? ProcessNodeResult.Success : ProcessNodeResult.Error;
            }
            finally
            {
                visitor.EndVisit(context, node);
            }
        }

        private ProcessNodeResult CallEvent(Object context, INodeVisitor visitor, Int32 tokenId, ASTNode node, IList<ParserMessage> messages)
        {
            switch (tokenId)
            {
                case 28: return visitor.ProcessAllCharNode(context, node, messages);
                case 50: return visitor.ProcessBooleanNode(context, node, messages);
                case 47: return visitor.ProcessCSharpIdentifierNode(context, node, messages);
                case 36: return visitor.ProcessCharacterClassNode(context, node, messages);
                case 74: return visitor.ProcessDefinitionNode(context, node, messages);
                case 23: return visitor.ProcessDropNode(context, node, messages);
                case 72: return visitor.ProcessExpressionNode(context, node, messages);
                case 76: return visitor.ProcessGrammarNode(context, node, messages);
                case 45: return visitor.ProcessIdentifierNode(context, node, messages);
                case 22: return visitor.ProcessIsTerminalNode(context, node, messages);
                case 42: return visitor.ProcessLiteralNode(context, node, messages);
                case 51: return visitor.ProcessNumberNode(context, node, messages);
                case 24: return visitor.ProcessOneOrMoreNode(context, node, messages);
                case 26: return visitor.ProcessOptionalNode(context, node, messages);
                case 70: return visitor.ProcessPrefixNode(context, node, messages);
                case 37: return visitor.ProcessRegexNode(context, node, messages);
                case 71: return visitor.ProcessSequenceNode(context, node, messages);
                case 69: return visitor.ProcessSuffixNode(context, node, messages);
                case 66: return visitor.ProcessTMDefinitionNode(context, node, messages);
                case 56: return visitor.ProcessTMIdentifierNode(context, node, messages);
                case 63: return visitor.ProcessTMIncludesNode(context, node, messages);
                case 61: return visitor.ProcessTMMatchNode(context, node, messages);
                case 62: return visitor.ProcessTMMatchSequenceNode(context, node, messages);
                case 60: return visitor.ProcessTMRegExNode(context, node, messages);
                case 58: return visitor.ProcessTMScopeNameNode(context, node, messages);
                case 20: return visitor.ProcessTreatInlineNode(context, node, messages);
                case 19: return visitor.ProcessUseRuleNameAsErrorNode(context, node, messages);
                case 54: return visitor.ProcessValuePairNode(context, node, messages);
                case 25: return visitor.ProcessZeroOrMoreNode(context, node, messages);
            }
            return ProcessNodeResult.Success;
        }
    }

    public class GrammarException : Exception
    {
        public GrammarException(String message, UInt32 row, UInt32 column) : base(message)
        {
            Row = row;
            Column = column;
        }

        public GrammarException(String message, (UInt32 row, UInt32 column) position) : base(message)
        {
            Row = position.row;
            Column = position.column;
        }

        public UInt32 Row { get; }
        public UInt32 Column { get; }
    }

    public class ASTNode
    {
        private List<ASTNode> _children { get; } = new List<ASTNode>();
        private ASTNode? _parent = null;

        public String Text { get; internal set; }
        public String Name { get; private set; }
        public IReadOnlyList<ASTNode> Children { get => _children; }
        public Int32 TokenId { get; private set; }
        public Int32 Position { get; internal set; }
        public ASTNode? Parent { get => _parent; }

        internal ASTNode(Int32 tokenId, String name, String text, Int32 position)
        {
            Text = text;
            TokenId = tokenId;
            Name = name;
            Position = position;
        }

        internal void AssignFrom(ASTNode node)
        {
            Int32 nodeIndex = _children.IndexOf(node);
            if (nodeIndex >= 0)
            {
                Text = node.Text;
                TokenId = node.TokenId;
                Position = node.Position;
                List<ASTNode> tempChildren = new List<ASTNode>(node.Children);
                foreach (ASTNode child in tempChildren)
                {
                    child.SetParent(this, nodeIndex);
                    nodeIndex++;
                }
                _children.Remove(node);
            }
        }

        internal String GetText()
        {
            if (Children.Count > 0)
                return String.Join("", Children.Select(x => x.GetText()));
            else
                return Text;
        }

        internal void SetParent(ASTNode? parent, Int32 index = -1)
        {
            if (_parent != null)
                _parent._children.Remove(this);
            _parent = parent;
            if (_parent != null)
            {
                if (index < 0)
                    _parent._children.Add(this);
                else
                    _parent._children.Insert(index, this);
            }
        }

        internal void AddChild(ASTNode? child)
        {
            if (child != null)
                _children.Add(child);
        }

        internal void ClearChildren()
        {
            _children.Clear();
        }
    }

    public class ParserMessage
    {
        public enum MessageType
        {
            Warning,
            Error
        }

        public ParserMessage(String message, MessageType type, (UInt32 row, UInt32 column) position)
        {
            Message = message;
            Row = position.row;
            Column = position.column;
            Type = type;
        }

        public String Message { get; }
        public UInt32 Row { get; }
        public UInt32 Column { get; }
        public MessageType Type { get; }
    }

    public class ParseidonParser
    {
        public ParseResult Parse(String text)
        {
            ParserState state = new ParserState(text, new MessageContext(text));
            ASTNode actualNode = new ASTNode(-1, "ROOT", "", 0);
            String? errorName = null;
            Boolean successful = CheckRule_Grammar(actualNode, state, errorName) && state.Position >= text.Length - 1;
            if (successful)
                state.NoError(state.Position);
            return new ParseResult(successful ? actualNode : null, state.MessageContext, state.Messages);
        }

        private class ParserState
        {
            public ParserState(String text, MessageContext messageContext)
            {
                Text = text;
                MessageContext = messageContext;
            }

            private readonly List<String> _terminalNames = new List<String>();
            private Int32 _lastErrorPosition = -1;
            private Int32 _lastParserPosition = -1;
            private List<String> _errorExpectations = new List<String>();
            private List<ParserMessage> _messages = new List<ParserMessage>();

            internal String Text { get; }
            internal Int32 Position { get; set; } = 0;
            internal Boolean Eof => !(Position < Text.Length);
            internal MessageContext MessageContext { get; }
            internal IReadOnlyList<ParserMessage> Messages
            {
                get
                {
                    var tempMessages = new List<ParserMessage>(_messages);
                    if (_errorExpectations.Count > 0)
                    {
                        String actual = _lastErrorPosition < Text.Length
                            ? $"found {DescribeLiteral(Text.Substring(_lastParserPosition, _lastErrorPosition - _lastParserPosition + 1))}"
                            : "found end of input";
                        String errorMessage = $"Expected {String.Join(" or ", _errorExpectations)}, {actual}!";
                        tempMessages.Add(new ParserMessage(errorMessage, ParserMessage.MessageType.Error, MessageContext.CalculateLocation(_lastParserPosition)));
                    }
                    return tempMessages;
                }
            }

            public void ReportError(String message, Int32 parserPosition, Int32 errorPosition)
            {
                if ((parserPosition >= _lastParserPosition) && (parserPosition < Text.Length))
                {
                    if (parserPosition > _lastParserPosition)
                        NoError(parserPosition);
                    if (!_errorExpectations.Contains(message))
                        _errorExpectations.Add(message);
                    _lastParserPosition = parserPosition;
                    if (errorPosition > _lastErrorPosition)
                        _lastErrorPosition = errorPosition;
                }
            }

            public void NoError(Int32 parserPosition)
            {
                if (parserPosition >= _lastParserPosition)
                    _errorExpectations.Clear();
            }
        }

        private static String DescribeLiteral(String value)
        {
            if (value.Length == 0)
                return "\"\"";

            StringBuilder builder = new StringBuilder(value.Length + 2);
            builder.Append('\"');
            foreach (Char character in value)
            {
                builder.Append(EscapeCharacter(character));
            }
            builder.Append('\"');
            return builder.ToString();
        }

        private static String DescribeCharacter(Char value) => $"\"{EscapeCharacter(value)}\"";

        private static String DescribePattern(String value)
        {
            StringBuilder builder = new StringBuilder(value.Length + 2);
            builder.Append('/');
            foreach (Char character in value)
            {
                builder.Append(EscapeCharacter(character));
            }
            builder.Append('/');
            return builder.ToString();
        }

        private static String EscapeCharacter(Char value)
        {
            return value switch
            {
                '\r' => "\\r",
                '\n' => "\\n",
                '\t' => "\\t",
                '\\' => "\\\\",
                '"' => "\\\"",
                '\'' => "\\'",
                _ when Char.IsControl(value) => $"\\x{((Int32)value):X2}",
                _ => value.ToString()
            };
        }

        private Boolean CheckRegEx(ASTNode parentNode, ParserState state, String? errorName, String regEx, Int32 quantifier)
        {
            Int32 oldPosition = state.Position;
            if ((state.Position < state.Text.Length) && (Regex.Match(state.Text.Substring(state.Position, quantifier), $"{regEx}{{{quantifier}}}") is Match regexMatch) && regexMatch.Success)
            {
                state.Position += regexMatch.Length;
                parentNode.AddChild(new ASTNode(-1, "REGEX", state.Text.Substring(oldPosition, state.Position - oldPosition), state.Position));
                state.NoError(state.Position);
                return true;
            }

            Int32 failurePosition = state.Position < state.Text.Length ? state.Position : state.Text.Length;
            state.Position = oldPosition;
            state.ReportError(errorName ?? $"input matching regex {DescribePattern(regEx)}", oldPosition, failurePosition);
            return false;
        }

        private Boolean CheckText(ASTNode parentNode, ParserState state, String? errorName, String text)
        {
            Int32 oldPosition = state.Position;
            Int32 position = 0;
            while (position < text.Length)
            {
                if (state.Eof || (state.Text[state.Position] != text[position]))
                {
                    Int32 failurePosition = state.Position < state.Text.Length ? state.Position : state.Text.Length;
                    state.Position = oldPosition;
                    state.ReportError(errorName ?? DescribeLiteral(text), oldPosition, failurePosition);
                    return false;
                }
                position++;
                state.Position++;
            }
            parentNode.AddChild(new ASTNode(-1, "TEXT", state.Text.Substring(oldPosition, state.Position - oldPosition), state.Position));
            state.NoError(state.Position);
            return true;
        }

        private Boolean CheckAnd(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, String?, Boolean> leftCheck, Func<ASTNode, String?, Boolean> rightCheck)
        {
            Int32 oldPosition = state.Position;
            ASTNode tempNode = new ASTNode(parentNode.TokenId, "AND", parentNode.Text, state.Position);
            tempNode.Position = parentNode.Position;
            if (leftCheck(tempNode, errorName))
            {
                if (rightCheck(tempNode, errorName))
                {
                    parentNode.AddChild(tempNode);
                    parentNode.AssignFrom(tempNode);
                    return true;
                }
            }
            state.Position = oldPosition;
            return false;
        }

        private Boolean CheckOr(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, String?, Boolean> leftCheck, Func<ASTNode, String?, Boolean> rightCheck)
        {
            Int32 oldPosition = state.Position;
            if (leftCheck(parentNode, errorName))
                return true;
            state.Position = oldPosition;
            return rightCheck(parentNode, errorName);
        }

        private Boolean Drop(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, String?, Boolean> check)
        {
            ASTNode tempNode = new ASTNode(-1, "", "", state.Position);
            return check(tempNode, errorName);
        }

        private Boolean CheckOneOrMore(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, String?, Boolean> check)
        {
            Int32 oldPosition = state.Position;
            if (!check(parentNode, errorName))
                return false;

            oldPosition = state.Position;
            while (!state.Eof)
            {
                Int32 snapshot = state.Position;
                if (!check(parentNode, errorName))
                {
                    state.Position = snapshot;
                    break;
                }
                if (state.Position == snapshot)
                    break;
                oldPosition = state.Position;
            }
            state.Position = oldPosition;
            return true;
        }

        private Boolean CheckZeroOrMore(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, String?, Boolean> check)
        {
            Int32 lastSuccessfulPosition = state.Position;
            while ((!state.Eof))
            {
                Int32 snapshot = state.Position;
                if (!check(parentNode, errorName))
                {
                    state.Position = snapshot;
                    break;
                }
                if (state.Position == snapshot)
                    break;
                lastSuccessfulPosition = state.Position;
            }
            state.Position = lastSuccessfulPosition;
            return true;
        }

        private Boolean CheckRange(ASTNode parentNode, ParserState state, String? errorName, Int32 minCount, Int32 maxCount, Func<ASTNode, String?, Boolean> check)
        {
            Int32 oldPosition = state.Position;
            Int32 count = 0;

            while (count < minCount)
            {
                if (!check(parentNode, errorName))
                {
                    state.Position = oldPosition;
                    return false;
                }
                count++;
                oldPosition = state.Position;
            }

            while ((count < maxCount) && !state.Eof)
            {
                Int32 snapshot = state.Position;
                if (!check(parentNode, errorName))
                {
                    state.Position = snapshot;
                    break;
                }
                if (state.Position == snapshot)
                    break;
                count++;
                oldPosition = state.Position;
            }

            state.Position = oldPosition;
            return true;
        }

        private Boolean MakeTerminal(ASTNode parentNode, ParserState state, String? errorName, Boolean doNotEscape, Func<ASTNode, String?, Boolean> check)
        {
            Int32 oldPosition = state.Position;
            ASTNode tempNode = new ASTNode(-1, "", "", state.Position);
            Boolean result = check(tempNode, errorName);
            if (result)
            {
                tempNode.Text = tempNode.GetText();
                tempNode.ClearChildren();
                parentNode.Text = tempNode.GetText();
                if (doNotEscape)
                    parentNode.Text = Regex.Unescape(parentNode.Text);
            }
            return result;
        }

        private Boolean SetErrorName(ASTNode parentNode, ParserState state, String? errorName, Func<ASTNode, String?, Boolean> check)
        {
            return check(parentNode, errorName);
        }

        private Boolean CheckRule_AllChar(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(28, "AllChar", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, ".");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Boolean(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(50, "Boolean", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "true"),
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "false")
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_CSharpIdentifier(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(47, "CSharpIdentifier", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "C# identifier",
                    (actualNode, errorName) => MakeTerminal(actualNode, state, errorName, false,
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z]", 1),
                            (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, ".")
                                    ),
                                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z0-9]", 1)
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Char(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(39, "Char", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[^'\\\\]", 1),
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\'"),
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\\\"),
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_EscapeChars(actualNode, state, errorName),
                                (actualNode, errorName) => CheckRule_UnicodeChars(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_CharacterClass(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(36, "CharacterClass", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "["),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "^")
                            ),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckOneOrMore(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule_ClassContent(actualNode, state, errorName)
                                ),
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "]")
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_ClassContent(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(34, "ClassContent", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule_SingleChar(actualNode, state, errorName),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "-"),
                            (actualNode, errorName) => CheckRule_SingleChar(actualNode, state, errorName)
                        )
                    ),
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule_PredefinedClass(actualNode, state, errorName),
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRule_EscapedChar(actualNode, state, errorName),
                            (actualNode, errorName) => CheckRule_SingleChar(actualNode, state, errorName)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Comment(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(13, "Comment", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "#"),
                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[^\\r\\n]", 1)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Definition(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(74, "Definition", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode, errorName) => CheckRule_UseRuleNameAsError(actualNode, state, errorName)
                        ),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule_IsTerminal(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckRule_Drop(actualNode, state, errorName)
                                )
                            ),
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckRule_TreatInline(actualNode, state, errorName)
                            )
                        )
                    ),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule_Identifier(actualNode, state, errorName),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "=")
                                ),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule_Expression(actualNode, state, errorName),
                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                    (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "{")
                                                    ),
                                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                            (actualNode, errorName) => CheckRule_ValuePair(actualNode, state, errorName),
                                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                            (actualNode, errorName) => CheckText(actualNode, state, errorName, ","),
                                                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                                    (actualNode, errorName) => CheckRule_ValuePair(actualNode, state, errorName),
                                                                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                                                                )
                                                                            )
                                                                        )
                                                                    ),
                                                                    (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "}")
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            ),
                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                    (actualNode, errorName) => SetErrorName(actualNode, state, "LineEnd",
                                                        (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                            (actualNode, errorName) => CheckText(actualNode, state, errorName, ";")
                                                        )
                                                    ),
                                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Drop(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(23, "Drop", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, "-");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_EscapeChars(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(38, "EscapeChars", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\"),
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[\\\\0abfnrtv\"'?]", 1)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_EscapedChar(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(31, "EscapedChar", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\"),
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[.\\\\\\[\\]\\-\\^]", 1)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Expression(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(72, "Expression", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRule_Sequence(actualNode, state, errorName),
                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRule_Or(actualNode, state, errorName),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                (actualNode, errorName) => CheckRule_Sequence(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Grammar(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(76, "Grammar", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_Option(actualNode, state, errorName),
                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                            )
                        ),
                        (actualNode, errorName) => CheckOneOrMore(actualNode, state, errorName,
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_Definition(actualNode, state, errorName),
                                (actualNode, errorName) => CheckRule_TMDefinition(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Identifier(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(45, "Identifier", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "Identifier",
                    (actualNode, errorName) => MakeTerminal(actualNode, state, errorName, false,
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "_"),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z]", 1),
                                (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z0-9]", 1)
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_IsTerminal(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(22, "IsTerminal", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "$"),
                    (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "$")
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Literal(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(42, "Literal", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "Literal",
                    (actualNode, errorName) => MakeTerminal(actualNode, state, errorName, false,
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "'")
                                ),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule_Char(actualNode, state, errorName)
                                    ),
                                    (actualNode, errorName) => Drop(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "'")
                                    )
                                )
                            ),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "\"")
                                ),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule_Char(actualNode, state, errorName)
                                    ),
                                    (actualNode, errorName) => Drop(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\"")
                                    )
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_NewLine(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(14, "NewLine", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "NewLine",
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\r\\n"),
                        (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[\\r\\n]", 1)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Number(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(51, "Number", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "Number",
                    (actualNode, errorName) => MakeTerminal(actualNode, state, errorName, false,
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "0"),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[1-9]", 1),
                                (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[0-9]", 1)
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_OneOrMore(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(24, "OneOrMore", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, "+");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Option(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(75, "Option", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "@"),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule_ValuePair(actualNode, state, errorName),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                            (actualNode, errorName) => SetErrorName(actualNode, state, "LineEnd",
                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, ";")
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Optional(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(26, "Optional", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, "?");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Or(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(27, "Or", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, "/");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_PredefinedClass(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(30, "PredefinedClass", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\d"),
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\D"),
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\w"),
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\W"),
                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\s"),
                                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\S"),
                                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\t"),
                                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\r"),
                                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\n"),
                                                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\v"),
                                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\f")
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Prefix(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(70, "Prefix", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                        (actualNode, errorName) => CheckRule_Drop(actualNode, state, errorName)
                    ),
                    (actualNode, errorName) => CheckRule_Suffix(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Regex(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(37, "Regex", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRule_CharacterClass(actualNode, state, errorName),
                    (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "{"),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_Number(actualNode, state, errorName),
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "}")
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Sequence(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(71, "Sequence", "", state.Position);
            Boolean result =
                CheckOneOrMore(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRule_Prefix(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_SingleChar(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(32, "SingleChar", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[^\\\\\\[\\]\\-]", 1),
                    (actualNode, errorName) => CheckRule_UnicodeChars(actualNode, state, errorName)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_Suffix(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(69, "Suffix", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckRule_TreatInline(actualNode, state, errorName)
                            ),
                            (actualNode, errorName) => CheckRule_Identifier(actualNode, state, errorName)
                        ),
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRule_Literal(actualNode, state, errorName),
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => Drop(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "(")
                                    ),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckRule_Expression(actualNode, state, errorName),
                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, ")")
                                                )
                                            )
                                        )
                                    )
                                ),
                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule_Regex(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckRule_AllChar(actualNode, state, errorName)
                                )
                            )
                        )
                    ),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_Optional(actualNode, state, errorName),
                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule_ZeroOrMore(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckRule_OneOrMore(actualNode, state, errorName)
                                )
                            )
                        ),
                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMDefinition(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(66, "TMDefinition", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRule_TMIdentifier(actualNode, state, errorName),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => Drop(actualNode, state, errorName,
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "=")
                            ),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckRule_TMScopeName(actualNode, state, errorName),
                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "(")
                                                ),
                                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                            (actualNode, errorName) => CheckRule_TMMatchSequence(actualNode, state, errorName),
                                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                                (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                        (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                                                            (actualNode, errorName) => CheckRule_TMIncludes(actualNode, state, errorName)
                                                                        ),
                                                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                                (actualNode, errorName) => CheckRule_TMMatchSequence(actualNode, state, errorName),
                                                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        ),
                                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                            (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                                (actualNode, errorName) => CheckText(actualNode, state, errorName, ")")
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        ),
                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckRule_TMMatchSequence(actualNode, state, errorName),
                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                        (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                                            (actualNode, errorName) => CheckRule_TMIncludes(actualNode, state, errorName)
                                                        ),
                                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                                (actualNode, errorName) => CheckRule_TMMatchSequence(actualNode, state, errorName),
                                                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    ),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                            (actualNode, errorName) => SetErrorName(actualNode, state, "LineEnd",
                                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, ";")
                                                )
                                            ),
                                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMIdentifier(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(56, "TMIdentifier", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "TextMate identifier",
                    (actualNode, errorName) => MakeTerminal(actualNode, state, errorName, false,
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => Drop(actualNode, state, errorName,
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "!")
                            ),
                            (actualNode, errorName) => CheckRule_Identifier(actualNode, state, errorName)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMIncludes(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(63, "TMIncludes", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "["),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule_TMIdentifier(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                        (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckRule_Or(actualNode, state, errorName)
                                                ),
                                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                                        (actualNode, errorName) => CheckRule_TMIdentifier(actualNode, state, errorName),
                                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            ),
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "]")
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMMatch(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(61, "TMMatch", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode, errorName) => CheckRule_TMScopeName(actualNode, state, errorName)
                        ),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => Drop(actualNode, state, errorName,
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "<")
                            ),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule_Expression(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                        (actualNode, errorName) => Drop(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckText(actualNode, state, errorName, ">")
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule_TMRegEx(actualNode, state, errorName),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckRule_TMScopeName(actualNode, state, errorName)
                            ),
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "(")
                                ),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckRule_TMMatchSequence(actualNode, state, errorName),
                                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                            (actualNode, errorName) => Drop(actualNode, state, errorName,
                                                (actualNode, errorName) => CheckText(actualNode, state, errorName, ")")
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMMatchSequence(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(62, "TMMatchSequence", "", state.Position);
            Boolean result =
                CheckOneOrMore(actualNode, state, errorName,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule_TMMatch(actualNode, state, errorName),
                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMRegEx(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(60, "TMRegEx", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, false,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => Drop(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "!'")
                        ),
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckOneOrMore(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_TMRegExChar(actualNode, state, errorName)
                            ),
                            (actualNode, errorName) => Drop(actualNode, state, errorName,
                                (actualNode, errorName) => CheckText(actualNode, state, errorName, "'")
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMRegExChar(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(59, "TMRegExChar", "", state.Position);
            Boolean result =
                CheckOr(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[^'\\\\]", 1),
                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\'"),
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\\\"),
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_EscapeChars(actualNode, state, errorName),
                                (actualNode, errorName) => CheckRule_UnicodeChars(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TMScopeName(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(58, "TMScopeName", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z]", 1),
                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                        (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, "."),
                                    (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "_"),
                                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "-")
                                    )
                                )
                            ),
                            (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[a-zA-Z0-9]", 1)
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_TreatInline(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(20, "TreatInline", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, ":");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_UnicodeChars(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(18, "UnicodeChars", "", state.Position);
            Boolean result =
                MakeTerminal(actualNode, state, errorName, true,
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckText(actualNode, state, errorName, "\\u"),
                        (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[0-9a-fA-F]", 4)
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_UseRuleNameAsError(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(19, "UseRuleNameAsError", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, "^");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_ValuePair(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(54, "ValuePair", "", state.Position);
            Boolean result =
                CheckAnd(actualNode, state, errorName,
                    (actualNode, errorName) => CheckRule_Identifier(actualNode, state, errorName),
                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                        (actualNode, errorName) => CheckRange(actualNode, state, errorName, 0, 1,
                            (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                (actualNode, errorName) => Drop(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckText(actualNode, state, errorName, ":")
                                ),
                                (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                    (actualNode, errorName) => CheckRule__(actualNode, state, errorName),
                                    (actualNode, errorName) => CheckAnd(actualNode, state, errorName,
                                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                            (actualNode, errorName) => CheckRule_Literal(actualNode, state, errorName),
                                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                                (actualNode, errorName) => CheckRule_Number(actualNode, state, errorName),
                                                (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                                    (actualNode, errorName) => CheckRule_Boolean(actualNode, state, errorName),
                                                    (actualNode, errorName) => CheckRule_CSharpIdentifier(actualNode, state, errorName)
                                                )
                                            )
                                        ),
                                        (actualNode, errorName) => CheckRule__(actualNode, state, errorName)
                                    )
                                )
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_WhiteSpace(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(15, "WhiteSpace", "", state.Position);
            Boolean result =
                SetErrorName(actualNode, state, "WhiteSpace",
                    (actualNode, errorName) => CheckRegEx(actualNode, state, errorName, "[ \\t]", 1)
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule_ZeroOrMore(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(25, "ZeroOrMore", "", state.Position);
            Boolean result =         CheckText(actualNode, state, errorName, "*");
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

        private Boolean CheckRule__(ASTNode parentNode, ParserState state, String? errorName)
        {
            Int32 oldPosition = state.Position;
            ASTNode actualNode = new ASTNode(16, "_", "", state.Position);
            Boolean result =
                Drop(actualNode, state, errorName,
                    (actualNode, errorName) => CheckZeroOrMore(actualNode, state, errorName,
                        (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                            (actualNode, errorName) => CheckRule_NewLine(actualNode, state, errorName),
                            (actualNode, errorName) => CheckOr(actualNode, state, errorName,
                                (actualNode, errorName) => CheckRule_WhiteSpace(actualNode, state, errorName),
                                (actualNode, errorName) => CheckRule_Comment(actualNode, state, errorName)
                            )
                        )
                    )
                );
            Int32 foundPosition = state.Position;
            if (result && ((actualNode.Children.Count > 0) || (actualNode.Text != "")))
                parentNode.AddChild(actualNode);
            return result;
        }

    }
}